<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Neon Pulse Platformer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #050505;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
        }
        canvas {
            box-shadow: 0 0 80px rgba(0, 255, 255, 0.2);
            border: 2px solid #333;
        }
        #ui {
            position: absolute;
            top: 20px;
            color: rgba(255, 255, 255, 0.7);
            text-align: center;
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 2px;
            z-index: 10;
        }
        .controls {
            font-size: 12px;
            margin-top: 5px;
            color: #555;
        }
    </style>
</head>
<body>

<div id="ui">
    <h1 id="title">NEON PULSE</h1>
    <div class="controls">Press Space or Enter to Start</div>
</div>

<canvas id="gameCanvas" width="800" height="600"></canvas>

<script>
/**
 * NEON PULSE ENGINE
 * ADDED: Pulsing Blocks (Type 5) and Levels 11 & 12 (Total 12 Levels)
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- GAME CONFIG ---
const CONFIG = {
    gravity: 0.6,
    friction: 0.82,
    speed: 7,
    jumpForce: -14,
    doubleJumpForce: -12,
    wallSlideSpeed: 1.5,
    wallJumpForceX: 10,
    pulseRate: 60, // frames per half-cycle (1 second on, 1 second off)
    colors: {
        bg: '#050505',
        player: '#00f3ff', // Cyan
        wall: '#bc13fe',   // Purple
        lava: '#ff073a',   // Red
        goal: '#ffe808',   // Yellow
        spike: '#0aff00',   // Green
        pulse: '#ff6600'   // Orange/Electric
    }
};

// --- GAME STATE ---
let shake = 0;
let particles = [];
let gameActive = false;
let gameState = 'MENU'; 
let currentLevelIndex = 0;
let currentMap = [];
let pulseTimer = 0; // Tracks the cycle of the pulsing blocks

const player = {
    x: 100, y: 400, w: 24, h: 24,
    vx: 0, vy: 0,
    canJump: false,
    jumpCount: 0,
    maxJumps: 2,
    scaleX: 1, scaleY: 1,
    dead: false,
    isWalled: 0 // -1 for left wall, 1 for right wall, 0 for none
};

// --- MAP DATA (Array of Levels) ---
// Type: 1=Wall, 2=Lava, 3=Goal, 4=Spike, 5=Pulsing Block
const levels = [
    // Levels 1-10 remain unchanged...
    { start: {x: 100, y: 400}, blocks: [ {x: 0, y: 580, w: 800, h: 20, type: 1}, {x: 0, y: 0, w: 20, h: 600, type: 1}, {x: 780, y: 0, w: 20, h: 600, type: 1}, {x: 0, y: 0, w: 800, h: 20, type: 1}, {x: 0, y: 500, w: 200, h: 20, type: 1}, {x: 250, y: 450, w: 150, h: 20, type: 1}, {x: 500, y: 380, w: 100, h: 20, type: 1}, {x: 150, y: 300, w: 200, h: 20, type: 1}, {x: 500, y: 220, w: 20, h: 100, type: 1}, {x: 650, y: 250, w: 100, h: 20, type: 1}, {x: 200, y: 560, w: 580, h: 20, type: 2}, {x: 300, y: 150, w: 20, h: 20, type: 2}, {x: 400, y: 100, w: 20, h: 20, type: 2}, {x: 700, y: 200, w: 30, h: 30, type: 3}  ] },
    { start: {x: 50, y: 400}, blocks: [ {x: 0, y: 580, w: 800, h: 20, type: 1}, {x: 0, y: 0, w: 20, h: 600, type: 1}, {x: 780, y: 0, w: 20, h: 600, type: 1}, {x: 0, y: 0, w: 800, h: 20, type: 1}, {x: 20, y: 500, w: 100, h: 20, type: 1}, {x: 200, y: 450, w: 50, h: 20, type: 1}, {x: 350, y: 400, w: 50, h: 20, type: 1}, {x: 500, y: 350, w: 50, h: 20, type: 1}, {x: 650, y: 300, w: 100, h: 20, type: 1}, {x: 120, y: 560, w: 660, h: 20, type: 2}, {x: 700, y: 240, w: 30, h: 30, type: 3} ] },
    { start: {x: 50, y: 400}, blocks: [ {x: 0, y: 580, w: 800, h: 20, type: 1}, {x: 0, y: 0, w: 20, h: 600, type: 1}, {x: 780, y: 0, w: 20, h: 600, type: 1}, {x: 0, y: 0, w: 800, h: 20, type: 1}, {x: 20, y: 500, w: 100, h: 20, type: 1}, {x: 200, y: 400, w: 50, h: 20, type: 1}, {x: 350, y: 300, w: 50, h: 20, type: 1}, {x: 500, y: 200, w: 50, h: 20, type: 1}, {x: 650, y: 150, w: 100, h: 20, type: 1}, {x: 120, y: 560, w: 660, h: 20, type: 2}, {x: 700, y: 90, w: 30, h: 30, type: 3} ] },
    { start: {x: 50, y: 550}, blocks: [ {x: 0, y: 580, w: 800, h: 20, type: 2}, {x: 0, y: 0, w: 20, h: 600, type: 1}, {x: 780, y: 0, w: 20, h: 600, type: 1}, {x: 0, y: 0, w: 800, h: 20, type: 1}, {x: 40, y: 550, w: 100, h: 30, type: 1}, {x: 200, y: 480, w: 50, h: 20, type: 1}, {x: 350, y: 400, w: 50, h: 20, type: 1}, {x: 550, y: 300, w: 50, h: 20, type: 1}, {x: 700, y: 200, w: 50, h: 20, type: 1}, {x: 650, y: 50, w: 100, h: 30, type: 1}, {x: 70, y: 50, w: 30, h: 30, type: 3} ] },
    { start: {x: 50, y: 550}, blocks: [ {x: 0, y: 580, w: 800, h: 20, type: 1}, {x: 0, y: 0, w: 20, h: 600, type: 1}, {x: 780, y: 0, w: 20, h: 600, type: 1}, {x: 0, y: 0, w: 800, h: 20, type: 1}, {x: 40, y: 550, w: 80, h: 30, type: 1}, {x: 200, y: 550, w: 80, h: 30, type: 1}, {x: 400, y: 550, w: 80, h: 30, type: 1}, {x: 600, y: 550, w: 80, h: 30, type: 1}, {x: 140, y: 560, w: 20, h: 20, type: 4}, {x: 340, y: 560, w: 20, h: 20, type: 4}, {x: 540, y: 560, w: 20, h: 20, type: 4}, {x: 740, y: 560, w: 20, h: 20, type: 4}, {x: 700, y: 490, w: 30, h: 30, type: 3} ] },
    { start: {x: 400, y: 550}, blocks: [ {x: 0, y: 580, w: 800, h: 20, type: 1}, {x: 0, y: 0, w: 20, h: 600, type: 1}, {x: 780, y: 0, w: 20, h: 600, type: 1}, {x: 0, y: 0, w: 800, h: 20, type: 1}, {x: 350, y: 550, w: 100, h: 30, type: 1}, {x: 200, y: 450, w: 50, h: 20, type: 1}, {x: 550, y: 450, w: 50, h: 20, type: 1}, {x: 150, y: 380, w: 500, h: 20, type: 4}, {x: 250, y: 300, w: 500, h: 20, type: 4}, {x: 400, y: 250, w: 50, h: 20, type: 1}, {x: 50, y: 150, w: 100, h: 20, type: 1}, {x: 650, y: 150, w: 100, h: 20, type: 1}, {x: 385, y: 100, w: 30, h: 30, type: 3} ] },
    { start: {x: 50, y: 550}, blocks: [ {x: 0, y: 580, w: 800, h: 20, type: 2}, {x: 0, y: 0, w: 20, h: 600, type: 1}, {x: 780, y: 0, w: 20, h: 600, type: 1}, {x: 0, y: 0, w: 800, h: 20, type: 1}, {x: 40, y: 550, w: 100, h: 30, type: 1}, {x: 200, y: 500, w: 50, h: 100, type: 1}, {x: 200, y: 350, w: 50, h: 100, type: 1}, {x: 200, y: 200, w: 50, h: 100, type: 1}, {x: 550, y: 500, w: 50, h: 100, type: 1}, {x: 550, y: 350, w: 50, h: 100, type: 1}, {x: 550, y: 200, w: 50, h: 100, type: 1}, {x: 375, y: 400, w: 50, h: 20, type: 1}, {x: 375, y: 250, w: 50, h: 20, type: 1}, {x: 700, y: 50, w: 30, h: 30, type: 3} ] },
    { start: {x: 50, y: 550}, blocks: [ {x: 0, y: 580, w: 800, h: 20, type: 1}, {x: 0, y: 0, w: 20, h: 600, type: 1}, {x: 780, y: 0, w: 20, h: 600, type: 1}, {x: 0, y: 0, w: 800, h: 20, type: 1}, {x: 40, y: 550, w: 100, h: 30, type: 1}, {x: 200, y: 450, w: 60, h: 100, type: 1}, {x: 300, y: 450, w: 300, h: 30, type: 1}, {x: 570, y: 350, w: 30, h: 100, type: 1}, {x: 400, y: 250, w: 300, h: 30, type: 1}, {x: 300, y: 150, w: 30, h: 100, type: 1}, {x: 200, y: 430, w: 60, h: 20, type: 4}, {x: 600, y: 430, w: 60, h: 20, type: 4}, {x: 400, y: 230, w: 60, h: 20, type: 4}, {x: 650, y: 100, w: 100, h: 20, type: 1}, {x: 700, y: 50, w: 30, h: 30, type: 3} ] },
    { start: {x: 700, y: 50}, blocks: [ {x: 0, y: 580, w: 800, h: 20, type: 2}, {x: 0, y: 0, w: 20, h: 600, type: 1}, {x: 780, y: 0, w: 20, h: 600, type: 1}, {x: 0, y: 0, w: 800, h: 20, type: 1}, {x: 650, y: 70, w: 100, h: 30, type: 1}, {x: 500, y: 150, w: 80, h: 20, type: 1}, {x: 350, y: 250, w: 80, h: 20, type: 1}, {x: 200, y: 350, w: 80, h: 20, type: 1}, {x: 50, y: 450, w: 80, h: 20, type: 1}, {x: 400, y: 150, w: 20, h: 300, type: 4}, {x: 700, y: 500, w: 30, h: 30, type: 3} ] },
    { start: {x: 50, y: 550}, blocks: [ {x: 0, y: 580, w: 800, h: 20, type: 2}, {x: 0, y: 0, w: 20, h: 600, type: 1}, {x: 780, y: 0, w: 20, h: 600, type: 1}, {x: 0, y: 0, w: 800, h: 20, type: 1}, {x: 40, y: 550, w: 100, h: 30, type: 1}, {x: 200, y: 550, w: 50, h: 30, type: 1}, {x: 350, y: 550, w: 50, h: 30, type: 1}, {x: 500, y: 550, w: 50, h: 30, type: 1}, {x: 650, y: 550, w: 50, h: 30, type: 1}, {x: 750, y: 450, w: 30, h: 20, type: 1}, {x: 700, y: 400, w: 20, h: 20, type: 4}, {x: 750, y: 350, w: 30, h: 20, type: 1}, {x: 200, y: 300, w: 500, h: 20, type: 4}, {x: 200, y: 400, w: 500, h: 20, type: 4}, {x: 50, y: 350, w: 100, h: 20, type: 1}, {x: 50, y: 250, w: 100, h: 20, type: 1}, {x: 100, y: 190, w: 30, h: 30, type: 3} ] },
    
    // --- NEW LEVELS ---

    // Level 11: The Rhythmist (Pulse Blocks)
    {
        start: {x: 50, y: 550},
        blocks: [
            {x: 0, y: 580, w: 800, h: 20, type: 1}, {x: 0, y: 0, w: 20, h: 600, type: 1},
            {x: 780, y: 0, w: 20, h: 600, type: 1}, {x: 0, y: 0, w: 800, h: 20, type: 1},
            {x: 40, y: 550, w: 100, h: 30, type: 1}, 

            // Pulsing blocks over a spike pit
            {x: 150, y: 560, w: 630, h: 20, type: 4}, // Pit floor
            
            {x: 200, y: 480, w: 50, h: 20, type: 5},  // Pulse 1
            {x: 350, y: 400, w: 50, h: 20, type: 5},  // Pulse 2
            {x: 500, y: 320, w: 50, h: 20, type: 5},  // Pulse 3
            
            // Long jump after Pulse 3
            {x: 650, y: 250, w: 100, h: 20, type: 1}, 
            {x: 700, y: 190, w: 30, h: 30, type: 3}
        ]
    },

    // Level 12: The Void (Final Test with all Hazards)
    {
        start: {x: 50, y: 550},
        blocks: [
            {x: 0, y: 580, w: 800, h: 20, type: 2}, // Lava floor
            {x: 0, y: 0, w: 20, h: 600, type: 1}, {x: 780, y: 0, w: 20, h: 600, type: 1},
            {x: 0, y: 0, w: 800, h: 20, type: 1},

            {x: 40, y: 550, w: 100, h: 30, type: 1}, // Start Platform

            // Wall jump section
            {x: 180, y: 450, w: 30, h: 100, type: 1}, 
            {x: 300, y: 350, w: 30, h: 100, type: 1},

            // Pulse jump section
            {x: 450, y: 350, w: 50, h: 20, type: 5}, // Pulse 1
            {x: 600, y: 250, w: 50, h: 20, type: 5}, // Pulse 2
            
            // Narrow spike squeeze
            {x: 700, y: 150, w: 50, h: 20, type: 4}, // Top spike
            {x: 700, y: 220, w: 50, h: 20, type: 4}, // Bottom spike
            {x: 750, y: 170, w: 30, h: 50, type: 1}, // End wall/climb

            {x: 700, y: 50, w: 30, h: 30, type: 3} // Final Goal
        ]
    }
];

// --- LEVEL MANAGEMENT (No change) ---

function loadLevel(index) {
    if (index >= levels.length) {
        winGame(true); 
        return;
    }

    currentLevelIndex = index;
    const levelData = levels[index];
    currentMap = levelData.blocks;

    player.x = levelData.start.x;
    player.y = levelData.start.y - player.h;

    player.vx = 0; player.vy = 0;
    player.dead = false;
    player.jumpCount = 0;
    shake = 0;
    gameActive = true;
    gameState = 'PLAYING';
    document.getElementById('title').innerText = `LEVEL ${index + 1} / ${levels.length}`;
    document.getElementById('title').style.color = CONFIG.colors.player;
    document.querySelector('.controls').innerHTML = "Arrows/WASD to Move • Space to Jump/Wall-Jump";
}

function resetGame() {
    loadLevel(currentLevelIndex);
}

function startNewGame() {
    currentLevelIndex = 0;
    loadLevel(currentLevelIndex);
}

// --- CONTROLS (Wall Jump logic remains the same) ---
const keys = {};

document.addEventListener('keydown', (e) => {
    if(["Space","ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].indexOf(e.code) > -1) {
        e.preventDefault();
    }
    
    keys[e.code] = true;

    if (gameState === 'MENU' && (e.code === 'Space' || e.code === 'Enter')) {
        startNewGame();
    } else if (gameState === 'DEAD' && e.code === 'KeyR') {
        resetGame();
    } else if (gameState === 'WIN' && e.code === 'KeyR') {
        if (currentLevelIndex >= levels.length) {
            gameState = 'MENU';
            document.getElementById('title').innerText = "NEON PULSE";
            document.querySelector('.controls').innerHTML = "Press Space or Enter to Start";
        } else {
            loadLevel(currentLevelIndex);
        }
    }

    if (gameState === 'PLAYING' && (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW')) {
        if (player.isWalled !== 0 && player.vy > 0) { 
            // Wall Jump
            player.vy = CONFIG.jumpForce;
            player.vx = -player.isWalled * CONFIG.wallJumpForceX; 
            player.jumpCount = 0; 
            player.isWalled = 0;
            squash(1.3, 0.7);
            spawnParticles(player.x + player.w/2, player.y + player.h/2, CONFIG.colors.wall, 10);
        } else if (player.canJump) {
            // Normal Jump
            player.vy = CONFIG.jumpForce;
            player.canJump = false;
            player.jumpCount = 1;
            squash(0.6, 1.4);
            spawnParticles(player.x + player.w/2, player.y + player.h, CONFIG.colors.player, 5);
        } else if (player.jumpCount < player.maxJumps) {
            // Double Jump
            player.vy = CONFIG.doubleJumpForce;
            player.jumpCount++;
            squash(0.7, 1.3);
            spawnParticles(player.x + player.w/2, player.y + player.h, '#ffffff', 8);
        }
    }
});

document.addEventListener('keyup', (e) => keys[e.code] = false);

// --- PHYSICS ENGINE (Updated for Pulsing Blocks) ---

function squash(x, y) {
    player.scaleX = x;
    player.scaleY = y;
}

function spawnParticles(x, y, color, count) {
    for (let i = 0; i < count; i++) {
        particles.push({
            x: x, y: y,
            vx: (Math.random() - 0.5) * 8,
            vy: (Math.random() - 0.5) * 8,
            life: 1.0,
            color: color
        });
    }
}

function checkRect(r1, r2) {
    return (r1.x < r2.x + r2.w && r1.x + r1.w > r2.x &&
            r1.y < r2.y + r2.h && r1.y + r1.h > r2.y);
}

// Function to check if a block is currently hazardous
function isBlockHazardous(block) {
    if (block.type === 2 || block.type === 4) { // Lava or Spike is always hazardous
        return true;
    }
    if (block.type === 5) { // Pulsing Block is hazardous during the 'ON' cycle
        return pulseTimer < CONFIG.pulseRate; 
    }
    return false;
}

// Function to check if a block is currently solid (can be stood on)
function isBlockSolid(block) {
    if (block.type === 1 || block.type === 4) { // Wall or Spike (spikes are solid platforms)
        return true;
    }
    if (block.type === 5) { // Pulsing Block is solid during the 'OFF' cycle
        return pulseTimer >= CONFIG.pulseRate;
    }
    return false;
}


function update() {
    if (gameState !== 'PLAYING') {
        if (shake > 0) shake *= 0.9;
        if (shake < 0.5) shake = 0;
        return;
    }

    // Update Pulse Timer
    pulseTimer = (pulseTimer + 1) % (CONFIG.pulseRate * 2);

    if (shake > 0) shake *= 0.9;
    if (shake < 0.5) shake = 0;

    player.scaleX += (1 - player.scaleX) * 0.1;
    player.scaleY += (1 - player.scaleY) * 0.1;

    if (player.dead) return;

    player.isWalled = 0; // Reset wall state every frame

    // Horizontal Movement
    let movingRight = keys['ArrowRight'] || keys['KeyD'];
    let movingLeft = keys['ArrowLeft'] || keys['KeyA'];

    if (movingRight) {
        if (player.vx < CONFIG.speed) player.vx++;
    } 
    else if (movingLeft) {
        if (player.vx > -CONFIG.speed) player.vx--;
    } 
    else {
        player.vx *= CONFIG.friction;
    }

    player.x += player.vx;

    // X Collisions (Check for Wall Stick)
    for (let b of currentMap) {
        if (checkRect(player, b)) {

            // Death Check
            if (isBlockHazardous(b)) {
                die();
                return;
            } 
            
            if (b.type === 3) { // Goal
                advanceLevel();
                return;
            }
            
            // Solid Collision Check
            if (isBlockSolid(b)) {
                if (player.vx > 0) {
                    player.x = b.x - player.w;
                    player.isWalled = 1; 
                } else if (player.vx < 0) {
                    player.x = b.x + b.w;
                    player.isWalled = -1; 
                }
                player.vx = 0;
            }
        }
    }

    // Apply Wall Sliding
    if (player.isWalled !== 0 && !player.canJump && (movingRight || movingLeft)) {
        if (player.vy > 0) {
            player.vy = Math.min(player.vy, CONFIG.wallSlideSpeed);
            player.jumpCount = 0; 
        }
    } else {
        // Normal Gravity
        player.vy += CONFIG.gravity;
    }

    player.y += player.vy;
    
    player.canJump = false; // Assume in air

    // Y Collisions
    for (let b of currentMap) {
        if (checkRect(player, b)) {
            // Death Check (again, if player landed on it during the hazardous cycle)
            if (isBlockHazardous(b)) { die(); return; }
            if (b.type === 3) { advanceLevel(); return; }

            // Solid Collision Response
            if (isBlockSolid(b)) {
                // Hitting Floor
                if (player.vy > 0) {
                    player.y = b.y - player.h;
                    player.vy = 0;
                    player.canJump = true;
                    player.jumpCount = 0;
                    if (player.vy > 10) squash(1.4, 0.6); 
                }
                // Hitting Ceiling
                else if (player.vy < 0) {
                    player.y = b.y + b.h;
                    player.vy = 0;
                }
            }
        }
    }

    // Bounds Check
    if (player.y > 600) die();
}

function advanceLevel() {
    if (gameState !== 'PLAYING') return;
    currentLevelIndex++;
    
    if (currentLevelIndex < levels.length) {
        winGame(false);
    } else {
        winGame(true);
    }
}

function die() {
    if (gameState !== 'PLAYING') return;
    gameState = 'DEAD';
    player.dead = true;
    shake = 20;
    spawnParticles(player.x, player.y, CONFIG.colors.player, 50);
    document.getElementById('title').innerText = "FATAL ERROR. PRESS R.";
    document.getElementById('title').style.color = "red";
    document.querySelector('.controls').innerHTML = "Press R to Restart Level";
}

function winGame(finalWin) {
    if (gameState !== 'PLAYING') return;
    gameState = 'WIN';
    player.dead = true; 
    shake = 10;
    spawnParticles(player.x, player.y, CONFIG.colors.goal, 50);

    if (finalWin) {
        document.getElementById('title').innerText = "ALL SYSTEMS ONLINE. PRESS R TO REBOOT.";
        document.getElementById('title').style.color = CONFIG.colors.goal;
        document.querySelector('.controls').innerHTML = "Press R to Return to Menu";
    } else {
        document.getElementById('title').innerText = `LEVEL ${currentLevelIndex} CLEARED. PRESS R FOR LEVEL ${currentLevelIndex + 1}`;
        document.getElementById('title').style.color = CONFIG.colors.goal;
        document.querySelector('.controls').innerHTML = "Press R to Continue";
    }
}

// --- RENDER ENGINE (Updated for Pulsing Blocks) ---

function drawGrid() {
    ctx.strokeStyle = '#111';
    ctx.lineWidth = 1;
    for(let i=0; i<800; i+=40) {
        ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,600); ctx.stroke();
    }
    for(let i=0; i<600; i+=40) {
        ctx.beginPath(); ctx.moveTo(0,i); ctx.lineTo(800,i); ctx.stroke();
    }
}

function drawMenu() {
    ctx.fillStyle = CONFIG.colors.bg;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    drawGrid();

    ctx.shadowBlur = 40;
    ctx.shadowColor = CONFIG.colors.player;
    ctx.font = '60px "Courier New"';
    ctx.textAlign = 'center';
    ctx.fillStyle = CONFIG.colors.player;
    ctx.fillText("NEON PULSE", canvas.width / 2, canvas.height / 2 - 50);
    
    ctx.shadowBlur = 10;
    ctx.shadowColor = 'white';
    ctx.font = '20px "Courier New"';
    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
    ctx.fillText("PRESS SPACE OR ENTER TO START", canvas.width / 2, canvas.height / 2 + 50);
    
    ctx.shadowBlur = 0;
}

function drawSpike(b) {
    ctx.fillStyle = CONFIG.colors.spike;
    ctx.shadowColor = CONFIG.colors.spike;
    ctx.beginPath();
    
    let midX = b.x + b.w / 2;
    let topY = b.y;
    let bottomY = b.y + b.h;

    ctx.moveTo(midX, topY); 
    ctx.lineTo(b.x, bottomY); 
    ctx.lineTo(b.x + b.w, bottomY); 
    ctx.closePath();
    ctx.fill();

    ctx.strokeStyle = CONFIG.colors.spike;
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.shadowBlur = 10;
    ctx.strokeStyle = CONFIG.colors.spike;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(b.x, bottomY);
    ctx.lineTo(b.x + b.w, bottomY);
    ctx.stroke();
    ctx.shadowBlur = 0;
}


function drawGame() {
    ctx.save();
    let dx = (Math.random() - 0.5) * shake;
    let dy = (Math.random() - 0.5) * shake;
    ctx.translate(dx, dy);

    ctx.fillStyle = CONFIG.colors.bg;
    ctx.fillRect(-50, -50, canvas.width+100, canvas.height+100);
    drawGrid();

    // 2. Map
    currentMap.forEach(b => {
        ctx.shadowBlur = 15;
        
        if (b.type === 1) { // Wall
            ctx.strokeStyle = CONFIG.colors.wall;
            ctx.shadowColor = CONFIG.colors.wall;
            ctx.lineWidth = 2;
            ctx.strokeRect(b.x, b.y, b.w, b.h);
        } else if (b.type === 2) { // Lava
            ctx.fillStyle = CONFIG.colors.lava;
            ctx.shadowColor = CONFIG.colors.lava;
            ctx.fillRect(b.x, b.y + 5, b.w, b.h - 5);
        } else if (b.type === 4) { // Spike
            drawSpike(b);
        } else if (b.type === 3) { // Goal
            ctx.fillStyle = CONFIG.colors.goal;
            ctx.shadowColor = CONFIG.colors.goal;
            ctx.fillRect(b.x, b.y, b.w, b.h);
            ctx.fillStyle = '#fff';
            ctx.fillRect(b.x + 10, b.y + 10, b.w - 20, b.h - 20);
        } else if (b.type === 5) { // Pulsing Block (Type 5)
            let isHazard = isBlockHazardous(b);
            ctx.shadowColor = isHazard ? CONFIG.colors.pulse : CONFIG.colors.wall;
            
            if (isHazard) {
                // Bright/Hazardous state
                ctx.fillStyle = CONFIG.colors.pulse;
                ctx.fillRect(b.x, b.y, b.w, b.h);
                ctx.lineWidth = 2;
                ctx.strokeRect(b.x, b.y, b.w, b.h);
            } else {
                // Dark/Solid state
                ctx.strokeStyle = CONFIG.colors.wall;
                ctx.lineWidth = 2;
                ctx.strokeRect(b.x, b.y, b.w, b.h);
            }
        }

        ctx.shadowBlur = 0;
    });

    // 3. Particles
    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.03;
        
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, 4, 4);
        ctx.globalAlpha = 1;

        if (p.life <= 0) particles.splice(i, 1);
    }

    // 4. Player
    if (!player.dead) {
        let cx = player.x + player.w/2;
        let cy = player.y + player.h;

        ctx.translate(cx, cy);
        ctx.scale(player.scaleX, player.scaleY);
        ctx.translate(-cx, -cy);

        ctx.shadowBlur = 20;
        ctx.shadowColor = CONFIG.colors.player;
        ctx.fillStyle = CONFIG.colors.player;
        ctx.fillRect(player.x, player.y, player.w, player.h);
        
        ctx.fillStyle = '#fff';
        ctx.fillRect(player.x+6, player.y+6, player.w-12, player.h-12);
        
        ctx.shadowBlur = 0;
        ctx.setTransform(1, 0, 0, 1, 0, 0); 
    }
    
    ctx.translate(dx, dy);

    // 5. Scanline Effect
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.fillStyle = "rgba(0, 0, 0, 0.1)";
    for (let i = 0; i < canvas.height; i += 4) {
        ctx.fillRect(0, i, canvas.width, 2);
    }

    ctx.restore();
}

function draw() {
    if (gameState === 'MENU') {
        drawMenu();
    } else {
        drawGame();
    }
}

// --- LOOP ---
function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}

document.querySelector('.controls').innerHTML = "Press Space or Enter to Start";
loop();

</script>
</body>
</html>
