<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Neon Jump Adventure</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            color: #fff;
        }
        #gameContainer {
            position: relative;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            border: 4px solid #444;
            border-radius: 4px;
        }
        canvas {
            display: block;
            background-color: #87CEEB; /* Fallback color */
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            text-shadow: 2px 2px 0 #000;
        }
        #controls {
            margin-top: 10px;
            text-align: center;
            font-size: 14px;
            color: #888;
        }
    </style>
</head>
<body>

    <div>
        <div id="gameContainer">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
            <div id="ui">
                <h2 id="statusText">Collect the Star!</h2>
            </div>
        </div>
        <div id="controls">
            Move: <b>WASD</b> or <b>Arrows</b> | Jump: <b>Space</b> or <b>Up</b> | Restart: <b>R</b>
        </div>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // --- Configuration ---
    const GAME_CONFIG = {
        gravity: 0.6,
        friction: 0.85,
        moveSpeed: 6,
        jumpPower: -12,
        coyoteTime: 10,     // Frames you can jump after falling off a ledge
        jumpBuffer: 10      // Frames a jump press is saved before landing
    };

    // --- State ---
    let gameState = 'playing'; // playing, win, dead
    let keys = {};
    let particles = [];
    
    // --- The Player ---
    const player = {
        x: 50, y: 400, w: 30, h: 30,
        vx: 0, vy: 0,
        grounded: false,
        coyoteCounter: 0,
        jumpBufferCounter: 0,
        color: '#fff',
        trail: []
    };

    // --- The Level ---
    // Types: 'solid', 'lava', 'bounce', 'moving'
    let platforms = [
        // Borders
        {x: 0, y: 580, w: 800, h: 20, type: 'solid'}, 
        {x: 0, y: 0, w: 20, h: 600, type: 'solid'},
        {x: 780, y: 0, w: 20, h: 600, type: 'solid'},
        
        // Starting area
        {x: 0, y: 500, w: 200, h: 40, type: 'solid'},
        
        // The Lava Pit
        {x: 200, y: 560, w: 580, h: 20, type: 'lava'},

        // Steps
        {x: 240, y: 430, w: 100, h: 20, type: 'solid'},
        {x: 80, y: 320, w: 100, h: 20, type: 'solid'},

        // Moving Platform (Note: dx is speed)
        {x: 250, y: 250, w: 100, h: 20, type: 'moving', dx: 2, minX: 250, maxX: 500},

        // Upper Section
        {x: 600, y: 200, w: 150, h: 20, type: 'solid'},
        {x: 450, y: 120, w: 80, h: 20, type: 'solid'},
        
        // A tricky jump
        {x: 200, y: 120, w: 40, h: 20, type: 'solid'}
    ];

    const goal = { x: 210, y: 70, r: 15, collected: false };

    // --- Input Handling ---
    window.addEventListener('keydown', e => {
        keys[e.code] = true;
        if (e.code === 'KeyR') resetGame();
        // Jump Buffering: If we press space, remember it for a few frames
        if (['Space', 'ArrowUp', 'KeyW'].includes(e.code)) {
            player.jumpBufferCounter = GAME_CONFIG.jumpBuffer;
        }
    });
    window.addEventListener('keyup', e => keys[e.code] = false);

    // --- Physics Helper ---
    function checkRectCollision(r1, r2) {
        return (r1.x < r2.x + r2.w && r1.x + r1.w > r2.x &&
                r1.y < r2.y + r2.h && r1.y + r1.h > r2.y);
    }

    function createParticles(x, y, color, count) {
        for(let i=0; i<count; i++) {
            particles.push({
                x: x, y: y,
                vx: (Math.random() - 0.5) * 10,
                vy: (Math.random() - 0.5) * 10,
                life: 60,
                color: color
            });
        }
    }

    function resetGame() {
        player.x = 50; player.y = 400;
        player.vx = 0; player.vy = 0;
        player.trail = [];
        goal.collected = false;
        gameState = 'playing';
        particles = [];
        document.getElementById('statusText').innerText = "Collect the Star!";
        document.getElementById('statusText').style.color = "white";
    }

    // --- Update Loop ---
    function update() {
        if (gameState !== 'playing') {
            // Update particles even when dead/win
            updateParticles();
            return;
        }

        // 1. Moving Platforms Logic
        platforms.forEach(p => {
            if (p.type === 'moving') {
                p.x += p.dx;
                if (p.x > p.maxX || p.x < p.minX) p.dx *= -1;
            }
        });

        // 2. Horizontal Movement
        if (keys['ArrowRight'] || keys['KeyD']) {
            if (player.vx < GAME_CONFIG.moveSpeed) player.vx++;
        } else if (keys['ArrowLeft'] || keys['KeyA']) {
            if (player.vx > -GAME_CONFIG.moveSpeed) player.vx--;
        } else {
            player.vx *= GAME_CONFIG.friction;
        }

        player.x += player.vx;

        // Horizontal Collisions
        platforms.forEach(p => {
            if (checkRectCollision(player, p)) {
                if (p.type === 'lava') killPlayer();
                
                // Solid collision
                if (player.vx > 0) player.x = p.x - player.w;
                else if (player.vx < 0) player.x = p.x + p.w;
                player.vx = 0;
            }
        });

        // 3. Vertical Movement
        player.vy += GAME_CONFIG.gravity;
        player.y += player.vy;
        
        player.grounded = false;

        // Vertical Collisions
        platforms.forEach(p => {
            if (checkRectCollision(player, p)) {
                if (p.type === 'lava') killPlayer();

                // Hitting floor
                if (player.vy > 0) {
                    player.y = p.y - player.h;
                    player.vy = 0;
                    player.grounded = true;
                    // If on moving platform, add its velocity to player
                    if (p.type === 'moving') player.x += p.dx;
                }
                // Hitting head
                else if (player.vy < 0) {
                    player.y = p.y + p.h;
                    player.vy = 0;
                }
            }
        });

        // 4. Jump Mechanics (Coyote + Buffer)
        if (player.grounded) {
            player.coyoteCounter = GAME_CONFIG.coyoteTime;
        } else {
            player.coyoteCounter--;
        }

        if (player.jumpBufferCounter > 0) {
            player.jumpBufferCounter--;
            // Try to jump
            if (player.coyoteCounter > 0) {
                player.vy = GAME_CONFIG.jumpPower;
                player.coyoteCounter = 0; 
                player.jumpBufferCounter = 0;
                // Add jump particles
                createParticles(player.x + player.w/2, player.y + player.h, '#fff', 5);
            }
        }

        // 5. Goal Collision
        // Circle collision check
        let dist = Math.hypot((player.x + player.w/2) - goal.x, (player.y + player.h/2) - goal.y);
        if (dist < goal.r + player.w/2 && !goal.collected) {
            winGame();
        }

        // Screen Bounds (fall off map)
        if (player.y > canvas.height) killPlayer();

        // Trail Logic
        if (Math.abs(player.vx) > 1 || Math.abs(player.vy) > 1) {
            player.trail.push({x: player.x, y: player.y, alpha: 0.5});
            if (player.trail.length > 10) player.trail.shift();
        }

        updateParticles();
    }

    function updateParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life--;
            if (p.life <= 0) particles.splice(i, 1);
        }
    }

    function killPlayer() {
        if (gameState === 'dead') return;
        gameState = 'dead';
        createParticles(player.x + player.w/2, player.y + player.h/2, '#e74c3c', 30);
        document.getElementById('statusText').innerText = "Game Over! Press R";
        document.getElementById('statusText').style.color = "#e74c3c";
    }

    function winGame() {
        goal.collected = true;
        gameState = 'win';
        createParticles(goal.x, goal.y, '#f1c40f', 50);
        document.getElementById('statusText').innerText = "You Win! Press R";
        document.getElementById('statusText').style.color = "#f1c40f";
    }

    // --- Drawing ---
    function draw() {
        // 1. Sky Gradient
        let grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grad.addColorStop(0, '#2c3e50');
        grad.addColorStop(1, '#4ca1af');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // 2. Draw Platforms
        platforms.forEach(p => {
            if (p.type === 'lava') {
                ctx.fillStyle = '#c0392b';
                ctx.fillRect(p.x, p.y + 5, p.w, p.h - 5);
                // Glow effect for lava
                ctx.shadowBlur = 20;
                ctx.shadowColor = 'red';
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(p.x, p.y, p.w, 5); // Top layer
                ctx.shadowBlur = 0;
            } else {
                // Dirt
                ctx.fillStyle = '#5d4037'; 
                ctx.fillRect(p.x, p.y, p.w, p.h);
                // Grass Top
                ctx.fillStyle = '#27ae60';
                ctx.fillRect(p.x, p.y, p.w, 6);
                
                if (p.type === 'moving') {
                    // Industrial look for moving platform
                    ctx.fillStyle = '#7f8c8d';
                    ctx.fillRect(p.x, p.y, p.w, p.h);
                    ctx.strokeStyle = '#2c3e50';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(p.x, p.y, p.w, p.h);
                    // Bolts
                    ctx.fillStyle = '#bdc3c7';
                    ctx.beginPath(); ctx.arc(p.x+5, p.y+5, 2, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(p.x+p.w-5, p.y+5, 2, 0, Math.PI*2); ctx.fill();
                }
            }
        });

        // 3. Draw Goal (Star)
        if (!goal.collected) {
            ctx.shadowBlur = 15;
            ctx.shadowColor = 'yellow';
            ctx.fillStyle = '#f1c40f';
            ctx.beginPath();
            ctx.arc(goal.x, goal.y, goal.r, 0, Math.PI*2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        // 4. Draw Particles
        particles.forEach(p => {
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.life / 60;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
        });

        // 5. Draw Player (Only if playing)
        if (gameState !== 'dead') {
            // Draw Trail
            player.trail.forEach(t => {
                ctx.fillStyle = `rgba(255, 255, 255, ${t.alpha})`;
                ctx.fillRect(t.x, t.y, player.w, player.h);
                t.alpha -= 0.05;
            });

            // Player Body
            ctx.fillStyle = player.color;
            ctx.shadowBlur = 10;
            ctx.shadowColor = 'white';
            ctx.fillRect(player.x, player.y, player.w, player.h);
            ctx.shadowBlur = 0;

            // Eyes (Look direction)
            ctx.fillStyle = 'black';
            let eyeOffset = (player.vx > 0) ? 6 : (player.vx < 0) ? -2 : 2;
            ctx.fillRect(player.x + 6 + eyeOffset, player.y + 8, 4, 8);
            ctx.fillRect(player.x + 18 + eyeOffset, player.y + 8, 4, 8);
        }
    }

    // --- Loop ---
    function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
    }

    loop();

</script>
</body>
</html>
