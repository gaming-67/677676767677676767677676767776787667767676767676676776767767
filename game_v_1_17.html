<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Neon Pulse Platformer</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #050505;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
        }
        canvas {
            box-shadow: 0 0 80px rgba(0, 255, 255, 0.2);
            border: 2px solid #333;
        }
        #ui {
            position: absolute;
            top: 20px;
            color: rgba(255, 255, 255, 0.7);
            text-align: center;
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 2px;
            z-index: 10;
            width: 800px;
        }
        #death-counter {
            position: absolute;
            top: 20px;
            left: 0;
            color: #ff073a;
            font-size: 16px;
            padding-left: 20px;
        }
    </style>
</head>
<body>

<div id="ui">
    <div id="death-counter">TOTAL DEATHS: 0</div>
</div>

<canvas id="gameCanvas" width="800" height="600"></canvas>

<script>
/**
 * NEON PULSE ENGINE
 * UPDATED: Level 13 difficulty reduced. Added 10 new levels (L20-L29). Total 30 levels.
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- GAME CONFIG ---
const CONFIG = {
    gravity: 0.6,
    friction: 0.82,
    speed: 7,
    jumpForce: -14,
    doubleJumpForce: -12,
    wallSlideSpeed: 1.5,
    wallJumpForceX: 10,
    coyoteTime: 6,
    pulseRate: 60, 
    jumpPadForceY: -25, 
    jumpPadForceX: 8,  
    colors: {
        bg: '#050505',
        player: '#00f3ff', 
        wall: '#bc13fe',   
        lava: '#ff073a',   
        goal: '#ffe808',   
        spike: '#0aff00',   
        pulse: '#ff6600',   
        moving: '#00ff88', 
        jumpPad: '#ff00ff',
        bounce: '#FFA500',
        phaseSolid: '#00b8e6', 
        phaseSpike: '#ff00ff',  
        key: '#ffff00', 
        lock: '#333333' 
    },
    // Menu Options dynamically updated on load
    mainMenuOptions: [],
    // Load persisted data
    highestCompletedLevel: parseInt(localStorage.getItem('neonPulseHighestLevel')) || 0
};

// --- GAME STATE ---
let shake = 0;
let particles = [];
let gameActive = false;
let gameState = 'MENU'; 
let currentLevelIndex = 0;
let currentMap = { blocks: [], hasKey: false }; // Updated to be an object to hold level state
let pulseTimer = 0; 
let menuScrollY = 0; 
let menuWaveOffset = 0; 

const player = {
    x: 100, y: 400, w: 24, h: 24,
    vx: 0, vy: 0,
    canJump: false,
    jumpCount: 0,
    maxJumps: 2,
    scaleX: 1, scaleY: 1,
    dead: false,
    isWalled: 0,
    coyoteTimer: 0, 
    deaths: parseInt(localStorage.getItem('neonPulseDeaths')) || 0,
    sessionDeaths: 0, 
    // Menu specific state
    menuState: 'MAIN', 
    menuSelection: 0, 
};

// --- MAP DATA (29 total levels now) ---
const levels = [
    // Level 1: Basic Jump
    { start: {x: 100, y: 400}, blocks: [ {x: 0, y: 580, w: 800, h: 20, type: 1}, {x: 0, y: 0, w: 20, h: 600, type: 1}, {x: 780, y: 0, w: 20, h: 600, type: 1}, {x: 0, y: 0, w: 800, h: 20, type: 1}, {x: 0, y: 500, w: 200, h: 20, type: 1}, {x: 250, y: 450, w: 150, h: 20, type: 1}, {x: 500, y: 380, w: 100, h: 20, type: 1}, {x: 150, y: 300, w: 200, h: 20, type: 1}, {x: 500, y: 220, w: 20, h: 100, type: 1}, {x: 650, y: 250, w: 100, h: 20, type: 1}, {x: 200, y: 560, w: 580, h: 20, type: 2}, {x: 300, y: 150, w: 20, h: 20, type: 2}, {x: 400, y: 100, w: 20, h: 20, type: 2}, {x: 700, y: 200, w: 30, h: 30, type: 3}  ] },
    // Level 2: Double Jump
    { start: {x: 50, y: 400}, blocks: [ {x: 0, y: 580, w: 800, h: 20, type: 1}, {x: 0, y: 0, w: 20, h: 600, type: 1}, {x: 780, y: 0, w: 20, h: 600, type: 1}, {x: 0, y: 0, w: 800, h: 20, type: 1}, {x: 20, y: 500, w: 100, h: 20, type: 1}, {x: 200, y: 450, w: 50, h: 20, type: 1}, {x: 350, y: 400, w: 50, h: 20, type: 1}, {x: 500, y: 350, w: 50, h: 20, type: 1}, {x: 650, y: 300, w: 100, h: 20, type: 1}, {x: 120, y: 560, w: 660, h: 20, type: 2}, {x: 700, y: 240, w: 30, h: 30, type: 3} ] },
    // Level 3: Wall Jump
    { start: {x: 50, y: 400}, blocks: [ {x: 0, y: 580, w: 800, h: 20, type: 1}, {x: 0, y: 0, w: 20, h: 600, type: 1}, {x: 780, y: 0, w: 20, h: 600, type: 1}, {x: 0, y: 0, w: 800, h: 20, type: 1}, {x: 20, y: 500, w: 100, h: 20, type: 1}, {x: 200, y: 400, w: 50, h: 20, type: 1}, {x: 350, y: 300, w: 50, h: 20, type: 1}, {x: 500, y: 200, w: 50, h: 20, type: 1}, {x: 650, y: 150, w: 100, h: 20, type: 1}, {x: 120, y: 560, w: 660, h: 20, type: 2}, {x: 700, y: 90, w: 30, h: 30, type: 3} ] },
    // Level 4: Spikes Intro
    { start: {x: 50, y: 550}, blocks: [ {x: 0, y: 580, w: 800, h: 20, type: 2}, {x: 0, y: 0, w: 20, h: 600, type: 1}, {x: 780, y: 0, w: 20, h: 600, type: 1}, {x: 0, y: 0, w: 800, h: 20, type: 1}, {x: 40, y: 550, w: 100, h: 30, type: 1}, {x: 200, y: 480, w: 50, h: 20, type: 1}, {x: 350, y: 400, w: 50, h: 20, type: 1}, {x: 550, y: 300, w: 50, h: 20, type: 1}, {x: 700, y: 200, w: 50, h: 20, type: 1}, {x: 650, y: 50, w: 100, h: 30, type: 1}, {x: 70, y: 50, w: 30, h: 30, type: 3} ] },
    // Level 5: Spike Gaps
    { start: {x: 50, y: 550}, blocks: [ {x: 0, y: 580, w: 800, h: 20, type: 1}, {x: 0, y: 0, w: 20, h: 600, type: 1}, {x: 780, y: 0, w: 20, h: 600, type: 1}, {x: 0, y: 0, w: 800, h: 20, type: 1}, {x: 40, y: 550, w: 80, h: 30, type: 1}, {x: 200, y: 550, w: 80, h: 30, type: 1}, {x: 400, y: 550, w: 80, h: 30, type: 1}, {x: 600, y: 550, w: 80, h: 30, type: 1}, {x: 140, y: 560, w: 20, h: 20, type: 4}, {x: 340, y: 560, w: 20, h: 20, type: 4}, {x: 540, y: 560, w: 20, h: 20, type: 4}, {x: 740, y: 560, w: 20, h: 20, type: 4}, {x: 700, y: 490, w: 30, h: 30, type: 3} ] },
    // Level 6: Wall Spike Run
    { start: {x: 400, y: 550}, blocks: [ {x: 0, y: 580, w: 800, h: 20, type: 2}, {x: 0, y: 0, w: 20, h: 600, type: 1}, {x: 780, y: 0, w: 20, h: 600, type: 1}, {x: 0, y: 0, w: 800, h: 20, type: 1}, {x: 350, y: 550, w: 100, h: 30, type: 1}, {x: 200, y: 450, w: 50, h: 20, type: 1}, {x: 550, y: 450, w: 50, h: 20, type: 1}, {x: 150, y: 380, w: 500, h: 20, type: 4}, {x: 250, y: 300, w: 500, h: 20, type: 4}, {x: 400, y: 250, w: 50, h: 20, type: 1}, {x: 50, y: 150, w: 100, h: 20, type: 1}, {x: 650, y: 150, w: 100, h: 20, type: 1}, {x: 385, y: 100, w: 30, h: 30, type: 3} ] },
    // Level 7: Tight Wall Jumps
    { start: {x: 50, y: 550}, blocks: [ {x: 0, y: 580, w: 800, h: 20, type: 2}, {x: 0, y: 0, w: 20, h: 600, type: 1}, {x: 780, y: 0, w: 20, h: 600, type: 1}, {x: 0, y: 0, w: 800, h: 20, type: 1}, {x: 40, y: 550, w: 100, h: 30, type: 1}, {x: 200, y: 500, w: 50, h: 100, type: 1}, {x: 200, y: 350, w: 50, h: 100, type: 1}, {x: 200, y: 200, w: 50, h: 100, type: 1}, {x: 550, y: 500, w: 50, h: 100, type: 1}, {x: 550, y: 350, w: 50, h: 100, type: 1}, {x: 550, y: 200, w: 50, h: 100, type: 1}, {x: 375, y: 400, w: 50, h: 20, type: 1}, {x: 375, y: 250, w: 50, h: 20, type: 1}, {x: 700, y: 50, w: 30, h: 30, type: 3} ] },
    // Level 8: Pulsing Block Intro (Pulsing is Type 5, Lava is Type 2)
    { start: {x: 50, y: 550}, blocks: [ {x: 0, y: 580, w: 800, h: 20, type: 1}, {x: 0, y: 0, w: 20, h: 600, type: 1}, {x: 780, y: 0, w: 20, h: 600, type: 1}, {x: 0, y: 0, w: 800, h: 20, type: 1}, {x: 40, y: 550, w: 100, h: 30, type: 1}, {x: 150, y: 560, w: 630, h: 20, type: 5}, {x: 200, y: 480, w: 50, h: 20, type: 1}, {x: 350, y: 400, w: 50, h: 20, type: 1}, {x: 500, y: 320, w: 50, h: 20, type: 1}, {x: 650, y: 250, w: 100, h: 20, type: 1}, {x: 700, y: 190, w: 30, h: 30, type: 3} ] },
    // Level 9: Pulsing Spike Wall
    { start: {x: 50, y: 550}, blocks: [ {x: 0, y: 580, w: 800, h: 20, type: 2}, {x: 0, y: 0, w: 20, h: 600, type: 1}, {x: 780, y: 0, w: 20, h: 600, type: 1}, {x: 0, y: 0, w: 800, h: 20, type: 1}, {x: 40, y: 550, w: 100, h: 30, type: 1}, {x: 180, y: 450, w: 30, h: 100, type: 1}, {x: 300, y: 350, w: 30, h: 100, type: 1}, {x: 450, y: 350, w: 50, h: 20, type: 5}, {x: 600, y: 250, w: 50, h: 20, type: 5}, {x: 700, y: 150, w: 50, h: 20, type: 4}, {x: 700, y: 220, w: 50, h: 20, type: 4}, {x: 750, y: 170, w: 30, h: 50, type: 1}, {x: 700, y: 50, w: 30, h: 30, type: 3} ] },
    // Level 10: Moving Platform X
    { start: {x: 50, y: 550}, blocks: [ {x: 0, y: 580, w: 800, h: 20, type: 2}, {x: 0, y: 0, w: 20, h: 600, type: 1}, {x: 780, y: 0, w: 20, h: 600, type: 1}, {x: 0, y: 0, w: 800, h: 20, type: 1}, {x: 40, y: 550, w: 100, h: 30, type: 1}, {x: 200, y: 500, w: 100, h: 20, type: 6, x1: 200, y1: 500, x2: 400, y2: 500, speed: 2}, {x: 550, y: 400, w: 150, h: 20, type: 6, x1: 550, y1: 400, x2: 750, y2: 400, speed: 3}, {x: 300, y: 300, w: 80, h: 20, type: 6, x1: 300, y1: 300, x2: 500, y2: 300, speed: 2}, {x: 650, y: 150, w: 100, h: 20, type: 1}, {x: 700, y: 90, w: 30, h: 30, type: 3} ] },
    // Level 11: Moving Platform Y
    { start: {x: 50, y: 550}, blocks: [ {x: 0, y: 580, w: 800, h: 20, type: 1}, {x: 0, y: 0, w: 20, h: 600, type: 1}, {x: 780, y: 0, w: 20, h: 600, type: 1}, {x: 0, y: 0, w: 800, h: 20, type: 1}, {x: 40, y: 550, w: 100, h: 30, type: 1}, {x: 650, y: 500, w: 100, h: 20, type: 1}, {x: 200, y: 500, w: 80, h: 20, type: 6, x1: 200, y1: 500, x2: 200, y2: 300, speed: 1.5}, {x: 400, y: 300, w: 80, h: 20, type: 6, x1: 400, y1: 300, x2: 400, y2: 100, speed: 2}, {x: 250, y: 400, w: 100, h: 20, type: 4}, {x: 500, y: 200, w: 200, h: 20, type: 2}, {x: 600, y: 100, w: 30, h: 30, type: 1}, {x: 700, y: 50, w: 30, h: 30, type: 3} ] },
    // Level 12: Jump Pad (Up)
    { start: {x: 50, y: 550}, blocks: [ {x: 0, y: 580, w: 800, h: 20, type: 1}, {x: 0, y: 0, w: 20, h: 600, type: 1}, {x: 780, y: 0, w: 20, h: 600, type: 1}, {x: 0, y: 0, w: 800, h: 20, type: 1}, {x: 40, y: 550, w: 100, h: 30, type: 1}, {x: 375, y: 560, w: 50, h: 20, type: 7, launchX: 0, launchY: CONFIG.jumpPadForceY}, {x: 375, y: 200, w: 50, h: 20, type: 4}, {x: 600, y: 450, w: 150, h: 20, type: 1}, {x: 650, y: 100, w: 100, h: 20, type: 1}, {x: 700, y: 50, w: 30, h: 30, type: 3} ] },
    // Level 13: Jump Pad (Diagonal) - ADJUSTED LAUNCH X
    { start: {x: 50, y: 550}, blocks: [ {x: 0, y: 580, w: 800, h: 20, type: 1}, {x: 0, y: 0, w: 20, h: 600, type: 1}, {x: 780, y: 0, w: 20, h: 600, type: 1}, {x: 0, y: 0, w: 800, h: 20, type: 1}, {x: 40, y: 550, w: 80, h: 30, type: 1}, {x: 180, y: 560, w: 50, h: 20, type: 7, launchX: 4, launchY: CONFIG.jumpPadForceY * 0.7}, 
        {x: 500, y: 450, w: 150, h: 20, type: 1}, {x: 20, y: 400, w: 760, h: 20, type: 2}, {x: 700, y: 500, w: 30, h: 30, type: 3} ] },
    // Level 14: Bounce Wall Intro
    { start: {x: 50, y: 550}, blocks: [ {x: 0, y: 580, w: 800, h: 20, type: 1}, {x: 0, y: 0, w: 20, h: 600, type: 1}, {x: 780, y: 0, w: 20, h: 600, type: 1}, {x: 0, y: 0, w: 800, h: 20, type: 1}, {x: 40, y: 550, w: 100, h: 30, type: 1}, {x: 250, y: 450, w: 50, h: 50, type: 8}, {x: 400, y: 350, w: 50, h: 50, type: 8}, {x: 550, y: 250, w: 50, h: 50, type: 8}, {x: 700, y: 150, w: 50, h: 50, type: 1}, {x: 700, y: 90, w: 30, h: 30, type: 3} ] },
    // Level 15: Bounce Wall + Spikes
    { start: {x: 50, y: 550}, blocks: [ {x: 0, y: 580, w: 800, h: 20, type: 2}, {x: 0, y: 0, w: 20, h: 600, type: 1}, {x: 780, y: 0, w: 20, h: 600, type: 1}, {x: 0, y: 0, w: 800, h: 20, type: 1}, {x: 40, y: 550, w: 100, h: 30, type: 1}, {x: 180, y: 450, w: 50, h: 130, type: 8}, {x: 350, y: 350, w: 50, h: 130, type: 8}, {x: 520, y: 250, w: 50, h: 130, type: 8}, {x: 230, y: 450, w: 120, h: 20, type: 4}, {x: 400, y: 350, w: 120, h: 20, type: 4}, {x: 570, y: 250, w: 120, h: 20, type: 4}, {x: 700, y: 150, w: 50, h: 20, type: 1}, {x: 700, y: 90, w: 30, h: 30, type: 3} ] },
    // Level 16: Jump Pad & Bounce Challenge
    { start: {x: 50, y: 550}, blocks: [ 
        {x: 0, y: 580, w: 800, h: 20, type: 1}, {x: 0, y: 0, w: 20, h: 600, type: 1}, {x: 780, y: 0, w: 20, h: 600, type: 1}, {x: 0, y: 0, w: 800, h: 20, type: 1}, 
        {x: 40, y: 550, w: 100, h: 30, type: 1}, 
        {x: 250, y: 560, w: 50, h: 20, type: 7, launchX: CONFIG.jumpPadForceX * 0.5, launchY: CONFIG.jumpPadForceY * 1.5},
        {x: 300, y: 560, w: 400, h: 20, type: 2}, 
        {x: 450, y: 400, w: 150, h: 20, type: 8},
        {x: 700, y: 400, w: 20, h: 150, type: 8},
        {x: 650, y: 200, w: 100, h: 20, type: 1}, 
        {x: 700, y: 140, w: 30, h: 30, type: 3} 
    ] },
    // Level 17: Phase Block Intro
    { start: {x: 50, y: 550}, blocks: [ 
        {x: 0, y: 580, w: 800, h: 20, type: 1}, {x: 0, y: 0, w: 20, h: 600, type: 1}, {x: 780, y: 0, w: 20, h: 600, type: 1}, {x: 0, y: 0, w: 800, h: 20, type: 1}, 
        {x: 40, y: 550, w: 100, h: 30, type: 1}, 
        {x: 200, y: 560, w: 50, h: 20, type: 9},
        {x: 300, y: 560, w: 50, h: 20, type: 9},
        {x: 400, y: 560, w: 50, h: 20, type: 9},
        {x: 500, y: 500, w: 100, h: 20, type: 1},
        {x: 600, y: 350, w: 20, h: 150, type: 9},
        {x: 650, y: 250, w: 30, h: 30, type: 3} 
    ] },
    // Level 18: Key and Lock Intro
    { start: {x: 50, y: 550}, blocks: [ 
        {x: 0, y: 580, w: 800, h: 20, type: 1}, {x: 0, y: 0, w: 20, h: 600, type: 1}, {x: 780, y: 0, w: 20, h: 600, type: 1}, {x: 0, y: 0, w: 800, h: 20, type: 1}, 
        {x: 40, y: 550, w: 100, h: 30, type: 1}, 
        {x: 700, y: 500, w: 20, h: 80, type: 11}, 
        {x: 250, y: 350, w: 300, h: 20, type: 1},
        {x: 400, y: 320, w: 20, h: 20, type: 10}, 
        {x: 580, y: 370, w: 20, h: 210, type: 1},
        {x: 180, y: 400, w: 20, h: 180, type: 1},
        {x: 200, y: 560, w: 380, h: 20, type: 4}, 
        {x: 700, y: 470, w: 30, h: 30, type: 3} 
    ] },
    // Level 19: Key, Lock & Moving Platform Combination
    { start: {x: 50, y: 550}, blocks: [ 
        {x: 0, y: 580, w: 800, h: 20, type: 1}, {x: 0, y: 0, w: 20, h: 600, type: 1}, {x: 780, y: 0, w: 20, h: 600, type: 1}, {x: 0, y: 0, w: 800, h: 20, type: 1}, 
        {x: 40, y: 550, w: 100, h: 30, type: 1}, 
        {x: 200, y: 500, w: 50, h: 20, type: 6, x1: 200, y1: 500, x2: 200, y2: 300, speed: 1.5},
        {x: 150, y: 280, w: 20, h: 20, type: 10},
        {x: 600, y: 500, w: 80, h: 20, type: 6, x1: 600, y1: 500, x2: 600, y2: 300, speed: 1},
        {x: 350, y: 300, w: 200, h: 20, type: 11},
        {x: 600, y: 250, w: 50, h: 20, type: 1},
        {x: 600, y: 200, w: 30, h: 30, type: 3} 
    ] },
    // --- NEW LEVELS START HERE ---

    // Level 20: Phasing Spikes + Key
    { start: {x: 50, y: 550}, blocks: [
        {x: 0, y: 580, w: 800, h: 20, type: 1}, {x: 0, y: 0, w: 20, h: 600, type: 1}, {x: 780, y: 0, w: 20, h: 600, type: 1}, {x: 0, y: 0, w: 800, h: 20, type: 1}, 
        {x: 40, y: 550, w: 100, h: 30, type: 1}, 
        {x: 200, y: 560, w: 500, h: 20, type: 9}, 
        {x: 350, y: 400, w: 50, h: 20, type: 1}, 
        {x: 550, y: 300, w: 50, h: 20, type: 1},
        {x: 700, y: 350, w: 20, h: 20, type: 10}, 
        {x: 700, y: 400, w: 20, h: 180, type: 11}, 
        {x: 740, y: 500, w: 30, h: 30, type: 3} 
    ] },

    // Level 21: Bounce Wall + Lock
    { start: {x: 50, y: 550}, blocks: [
        {x: 0, y: 580, w: 800, h: 20, type: 1}, {x: 0, y: 0, w: 20, h: 600, type: 1}, {x: 780, y: 0, w: 20, h: 600, type: 1}, {x: 0, y: 0, w: 800, h: 20, type: 1}, 
        {x: 40, y: 550, w: 100, h: 30, type: 1}, 
        {x: 160, y: 400, w: 50, h: 180, type: 8}, 
        {x: 300, y: 300, w: 50, h: 180, type: 8}, 
        {x: 450, y: 200, w: 50, h: 180, type: 8}, 
        {x: 600, y: 100, w: 50, h: 20, type: 1}, 
        {x: 615, y: 70, w: 20, h: 20, type: 10}, 
        {x: 700, y: 300, w: 20, h: 280, type: 11}, 
        {x: 740, y: 50, w: 30, h: 30, type: 3} 
    ] },

    // Level 22: Moving Spikes
    { start: {x: 50, y: 550}, blocks: [
        {x: 0, y: 580, w: 800, h: 20, type: 1}, {x: 0, y: 0, w: 20, h: 600, type: 1}, {x: 780, y: 0, w: 20, h: 600, type: 1}, {x: 0, y: 0, w: 800, h: 20, type: 1}, 
        {x: 40, y: 550, w: 100, h: 30, type: 1}, 
        {x: 200, y: 500, w: 50, h: 20, type: 6, x1: 200, y1: 500, x2: 400, y2: 500, speed: 2},
        {x: 450, y: 400, w: 50, h: 20, type: 6, x1: 450, y1: 400, x2: 650, y2: 400, speed: 3},
        {x: 250, y: 300, w: 200, h: 20, type: 4}, 
        {x: 500, y: 300, w: 100, h: 20, type: 1},
        {x: 350, y: 560, w: 100, h: 20, type: 4},
        {x: 680, y: 560, w: 100, h: 20, type: 4},
        {x: 700, y: 340, w: 30, h: 30, type: 3} 
    ] },

    // Level 23: Jump Pad Puzzle (Key Acquisition)
    { start: {x: 50, y: 550}, blocks: [
        {x: 0, y: 580, w: 800, h: 20, type: 1}, {x: 0, y: 0, w: 20, h: 600, type: 1}, {x: 780, y: 0, w: 20, h: 600, type: 1}, {x: 0, y: 0, w: 800, h: 20, type: 1}, 
        {x: 40, y: 550, w: 100, h: 30, type: 1}, 
        {x: 180, y: 560, w: 50, h: 20, type: 7, launchX: 0, launchY: CONFIG.jumpPadForceY}, 
        {x: 250, y: 350, w: 50, h: 20, type: 7, launchX: CONFIG.jumpPadForceX * 1.2, launchY: CONFIG.jumpPadForceY * 0.5}, 
        {x: 500, y: 200, w: 50, h: 20, type: 7, launchX: 0, launchY: CONFIG.jumpPadForceY}, 
        {x: 580, y: 50, w: 50, h: 20, type: 1},
        {x: 600, y: 20, w: 20, h: 20, type: 10}, 
        {x: 700, y: 450, w: 20, h: 130, type: 11}, 
        {x: 740, y: 500, w: 30, h: 30, type: 3} 
    ] },
    
    // Level 24: Double Phasing
    { start: {x: 50, y: 550}, blocks: [
        {x: 0, y: 580, w: 800, h: 20, type: 1}, {x: 0, y: 0, w: 20, h: 600, type: 1}, {x: 780, y: 0, w: 20, h: 600, type: 1}, {x: 0, y: 0, w: 800, h: 20, type: 1}, 
        {x: 40, y: 550, w: 100, h: 30, type: 1}, 
        {x: 200, y: 560, w: 150, h: 20, type: 9}, 
        {x: 450, y: 560, w: 150, h: 20, type: 5}, 
        {x: 650, y: 400, w: 100, h: 20, type: 1},
        {x: 350, y: 400, w: 50, h: 20, type: 9}, 
        {x: 500, y: 250, w: 50, h: 20, type: 5}, 
        {x: 700, y: 340, w: 30, h: 30, type: 3} 
    ] },

    // Level 25: Lava Platforming (Precise Double Jump)
    { start: {x: 50, y: 550}, blocks: [
        {x: 0, y: 580, w: 800, h: 20, type: 2}, 
        {x: 0, y: 0, w: 20, h: 600, type: 1}, {x: 780, y: 0, w: 20, h: 600, type: 1}, {x: 0, y: 0, w: 800, h: 20, type: 1}, 
        {x: 40, y: 550, w: 80, h: 30, type: 1}, 
        {x: 180, y: 500, w: 50, h: 20, type: 1}, 
        {x: 300, y: 450, w: 50, h: 20, type: 1}, 
        {x: 420, y: 400, w: 50, h: 20, type: 1}, 
        {x: 540, y: 350, w: 50, h: 20, type: 1}, 
        {x: 660, y: 300, w: 50, h: 20, type: 1}, 
        {x: 740, y: 240, w: 30, h: 30, type: 3} 
    ] },

    // Level 26: Moving Key/Lock Timing
    { start: {x: 50, y: 550}, blocks: [
        {x: 0, y: 580, w: 800, h: 20, type: 1}, {x: 0, y: 0, w: 20, h: 600, type: 1}, {x: 780, y: 0, w: 20, h: 600, type: 1}, {x: 0, y: 0, w: 800, h: 20, type: 1}, 
        {x: 40, y: 550, w: 100, h: 30, type: 1}, 
        {x: 200, y: 400, w: 50, h: 20, type: 6, x1: 200, y1: 400, x2: 400, y2: 400, speed: 2}, 
        {x: 300, y: 380, w: 20, h: 20, type: 10}, 
        {x: 600, y: 500, w: 20, h: 80, type: 11}, 
        {x: 650, y: 400, w: 20, h: 80, type: 11}, 
        {x: 700, y: 300, w: 20, h: 80, type: 11}, 
        {x: 740, y: 240, w: 30, h: 30, type: 3} 
    ] },

    // Level 27: Vertical Shaft Climb (Bounce/Wall Jump)
    { start: {x: 50, y: 550}, blocks: [
        {x: 0, y: 580, w: 800, h: 20, type: 1}, {x: 0, y: 0, w: 20, h: 600, type: 1}, {x: 780, y: 0, w: 20, h: 600, type: 1}, {x: 0, y: 0, w: 800, h: 20, type: 1}, 
        {x: 40, y: 550, w: 100, h: 30, type: 1}, 
        {x: 200, y: 500, w: 50, h: 80, type: 1}, 
        {x: 550, y: 500, w: 230, h: 20, type: 1}, 
        {x: 250, y: 400, w: 300, h: 20, type: 2}, 
        {x: 200, y: 300, w: 50, h: 80, type: 8}, 
        {x: 550, y: 300, w: 50, h: 80, type: 8}, 
        {x: 200, y: 100, w: 50, h: 80, type: 1}, 
        {x: 550, y: 100, w: 50, h: 80, type: 1}, 
        {x: 250, y: 80, w: 300, h: 20, type: 4}, 
        {x: 650, y: 440, w: 30, h: 30, type: 3} 
    ] },

    // Level 28: Final Timed Run
    { start: {x: 50, y: 550}, blocks: [
        {x: 0, y: 580, w: 800, h: 20, type: 1}, {x: 0, y: 0, w: 20, h: 600, type: 1}, {x: 780, y: 0, w: 20, h: 600, type: 1}, {x: 0, y: 0, w: 800, h: 20, type: 1}, 
        {x: 40, y: 550, w: 100, h: 30, type: 1}, 
        {x: 180, y: 560, w: 150, h: 20, type: 5}, 
        {x: 350, y: 560, w: 150, h: 20, type: 9}, 
        {x: 520, y: 500, w: 50, h: 20, type: 1},
        {x: 600, y: 400, w: 50, h: 20, type: 6, x1: 600, y1: 400, x2: 750, y2: 400, speed: 2}, 
        {x: 550, y: 560, w: 20, h: 20, type: 4}, 
        {x: 750, y: 560, w: 20, h: 20, type: 4}, 
        {x: 700, y: 340, w: 30, h: 30, type: 3} 
    ] },
    
    // Level 29: Grand Finale (Key, Lock, Bounce, Jump Pads)
    { start: {x: 50, y: 550}, blocks: [
        {x: 0, y: 580, w: 800, h: 20, type: 1}, {x: 0, y: 0, w: 20, h: 600, type: 1}, {x: 780, y: 0, w: 20, h: 600, type: 1}, {x: 0, y: 0, w: 800, h: 20, type: 1}, 
        {x: 40, y: 550, w: 100, h: 30, type: 1}, 
        
        {x: 200, y: 560, w: 50, h: 20, type: 7, launchX: 0, launchY: CONFIG.jumpPadForceY},
        {x: 300, y: 300, w: 20, h: 20, type: 10}, 
        {x: 250, y: 320, w: 150, h: 20, type: 1},
        
        {x: 450, y: 320, w: 100, h: 20, type: 11}, 
        {x: 580, y: 300, w: 50, h: 100, type: 8}, 
        
        {x: 650, y: 500, w: 100, h: 20, type: 6, x1: 650, y1: 500, x2: 650, y2: 300, speed: 1}, 
        {x: 700, y: 250, w: 30, h: 30, type: 3} 
    ] },

    // Placeholder level for expansion (Level 30 - Index 29)
    { start: {x: 50, y: 550}, blocks: [ {x: 0, y: 580, w: 800, h: 20, type: 1}, {x: 0, y: 0, w: 20, h: 600, type: 1}, {x: 780, y: 0, w: 20, h: 600, type: 1}, {x: 0, y: 0, w: 800, h: 20, type: 1}, {x: 40, y: 550, w: 100, h: 30, type: 1}, {x: 700, y: 50, w: 30, h: 30, type: 3} ] },
];


// --- LEVEL MANAGEMENT ---

function getHighestCompletedLevel() {
    return parseInt(localStorage.getItem('neonPulseHighestLevel')) || 0;
}

function updateMainMenuOptions() {
    const highestLevel = getHighestCompletedLevel();
    if (highestLevel > 0 && highestLevel < levels.length) {
        CONFIG.mainMenuOptions = [`CONTINUE (Level ${highestLevel + 1})`, "LEVEL SELECT", "CONTROLS & LORE"];
    } else {
        CONFIG.mainMenuOptions = ["START NEW GAME", "LEVEL SELECT", "CONTROLS & LORE"];
    }
}

function loadLevel(index) {
    if (index >= levels.length) {
        winGame(true); 
        return;
    }

    currentLevelIndex = index;
    const levelData = levels[index];
    
    currentMap.blocks = levelData.blocks.map(b => {
        if (b.type === 6) {
            return {
                ...b,
                currentX: b.x, currentY: b.y,
                vx: (b.x2 - b.x1) ? b.speed : 0, 
                vy: (b.y2 - b.y1) ? b.speed : 0,
                dx: 0, dy: 0
            };
        }
        return b;
    });
    
    // Initialize level state variables
    currentMap.hasKey = false; 

    player.x = levelData.start.x;
    player.y = levelData.start.y - player.h;

    player.vx = 0; player.vy = 0;
    player.dead = false;
    player.jumpCount = 0;
    player.coyoteTimer = 0;
    shake = 0;
    gameActive = true;
    gameState = 'PLAYING';
    
    document.getElementById('death-counter').style.visibility = 'visible';
    updateHUD();
}

function resetGame() {
    loadLevel(currentLevelIndex);
}

function startNewGame(level = 0) {
    player.sessionDeaths = 0; 
    currentLevelIndex = level;
    loadLevel(currentLevelIndex);
}

function updateHUD() {
    document.getElementById('death-counter').innerText = `DEATHS: ${player.sessionDeaths || 0}`;
}

// --- CONTROLS ---
const keys = {};
let lastKeyTime = 0;
const debounceTime = 150; 

document.addEventListener('keydown', (e) => {
    if(["Space","ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Enter","KeyW","KeyS","KeyA","KeyD"].indexOf(e.code) > -1) {
        e.preventDefault();
    }
    
    const now = Date.now();
    const isDebounced = (now - lastKeyTime < debounceTime);
    lastKeyTime = now;
    
    keys[e.code] = true;

    if (gameState === 'MENU') {
        if (isDebounced) return;
        
        const currentMenu = player.menuState;

        if (currentMenu === 'MAIN') {
            if (e.code === 'ArrowDown' || e.code === 'KeyS') {
                player.menuSelection = (player.menuSelection + 1) % CONFIG.mainMenuOptions.length;
            } else if (e.code === 'ArrowUp' || e.code === 'KeyW') {
                player.menuSelection = (player.menuSelection - 1 + CONFIG.mainMenuOptions.length) % CONFIG.mainMenuOptions.length;
            } else if (e.code === 'Enter' || e.code === 'Space') {
                const selection = CONFIG.mainMenuOptions[player.menuSelection];
                if (selection.startsWith("CONTINUE") || selection === "START NEW GAME") {
                    startNewGame(getHighestCompletedLevel());
                } else if (selection === "LEVEL SELECT") {
                    player.menuState = 'LEVEL_SELECT';
                    player.menuSelection = currentLevelIndex;
                } else if (selection === "CONTROLS & LORE") {
                    player.menuState = 'CONTROLS';
                    player.menuSelection = 0; 
                }
            }
        } else if (currentMenu === 'LEVEL_SELECT') {
            const maxLevels = levels.length - 1; 
            if (e.code === 'ArrowRight' || e.code === 'KeyD') {
                player.menuSelection = (player.menuSelection + 1) % maxLevels;
            } else if (e.code === 'ArrowLeft' || e.code === 'KeyA') {
                player.menuSelection = (player.menuSelection - 1 + maxLevels) % maxLevels;
            } else if (e.code === 'Enter' || e.code === 'Space') {
                if (player.menuSelection <= getHighestCompletedLevel()) {
                    startNewGame(player.menuSelection);
                } else {
                    // Flash screen to indicate locked level
                    shake = 5;
                }
            } else if (e.code === 'Escape' || e.code === 'KeyB') {
                player.menuState = 'MAIN';
                player.menuSelection = 0;
                updateMainMenuOptions();
            }
        } else if (currentMenu === 'CONTROLS') {
            if (e.code === 'Escape' || e.code === 'KeyB' || e.code === 'Enter' || e.code === 'Space') {
                player.menuState = 'MAIN';
                player.menuSelection = CONFIG.mainMenuOptions.findIndex(opt => opt === "CONTROLS & LORE");
                updateMainMenuOptions();
            }
        }
    } 
    // --- In-Game Controls ---
    else if (gameState === 'DEAD' && e.code === 'KeyR') {
        resetGame();
    } else if (gameState === 'WIN' && e.code === 'KeyR') {
        if (currentLevelIndex >= levels.length - 1) { 
            gameState = 'MENU';
            player.menuState = 'MAIN';
            player.menuSelection = 0;
            updateMainMenuOptions();
            document.getElementById('death-counter').innerText = `TOTAL DEATHS: ${player.deaths}`; 
        } else {
            loadLevel(currentLevelIndex);
        }
    } else if (gameState === 'PLAYING' && (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW')) {
        // Wall Jump Check
        if (player.isWalled !== 0 && player.vy > 0) { 
            player.vy = CONFIG.jumpForce;
            player.vx = -player.isWalled * CONFIG.wallJumpForceX; 
            player.jumpCount = 0; 
            player.isWalled = 0;
            squash(1.3, 0.7);
            spawnParticles(player.x + player.w/2, player.y + player.h/2, CONFIG.colors.wall, 10);
        } 
        // Ground Jump / Coyote Time Jump Check
        else if (player.canJump || player.coyoteTimer > 0) {
            player.vy = CONFIG.jumpForce;
            player.canJump = false;
            player.coyoteTimer = 0; 
            player.jumpCount = 1;
            squash(0.6, 1.4);
            spawnParticles(player.x + player.w/2, player.y + player.h, CONFIG.colors.player, 5);
        } 
        // Double Jump Check
        else if (player.jumpCount < player.maxJumps) {
            player.vy = CONFIG.doubleJumpForce;
            player.jumpCount++;
            squash(0.7, 1.3);
            spawnParticles(player.x + player.w/2, player.y + player.h, '#ffffff', 8);
        }
    }
});

document.addEventListener('keyup', (e) => keys[e.code] = false);

// --- PHYSICS ENGINE ---

function squash(x, y) {
    player.scaleX = x;
    player.scaleY = y;
}

function spawnParticles(x, y, color, count) {
    for (let i = 0; i < count; i++) {
        particles.push({
            x: x, y: y,
            vx: (Math.random() - 0.5) * 8,
            vy: (Math.random() - 0.5) * 8,
            life: 1.0,
            color: color
        });
    }
}

function checkRect(r1, r2) {
    return (r1.x < r2.x + r2.w && r1.x + r1.w > r2.x &&
            r1.y < r2.y + r2.h && r1.y + r1.h > r2.y);
}

function isBlockHazardous(block) {
    if (block.type === 2 || block.type === 4) return true;
    if (block.type === 5) return pulseTimer < CONFIG.pulseRate; 
    if (block.type === 9) return pulseTimer >= CONFIG.pulseRate;
    return false;
}

function isBlockSolid(block) {
    // Type 1, 4 (spikes are solid on the sides/bottom), 6, 7, 8 are always solid
    if (block.type === 1 || block.type === 4 || block.type === 6 || block.type === 7 || block.type === 8) return true;
    
    // Pulsing Blocks (Type 5) and Phase Blocks (Type 9) are conditionally solid
    if (block.type === 5) return pulseTimer >= CONFIG.pulseRate;
    if (block.type === 9) return pulseTimer < CONFIG.pulseRate;
    
    // Lock Blocks (Type 11) are solid ONLY if the key has NOT been collected
    if (block.type === 11) return !currentMap.hasKey;
    
    return false;
}

function updateMovingPlatforms(block) {
    if (block.type !== 6) return;

    block.dx = 0; block.dy = 0;
    let targetX, targetY;

    if (block.vx > 0 || block.vy > 0) {
        targetX = block.x2; targetY = block.y2;
    } else {
        targetX = block.x1; targetY = block.y1;
    }

    if (block.currentX < targetX) {
        block.dx = Math.min(block.speed, targetX - block.currentX);
    } else if (block.currentX > targetX) {
        block.dx = Math.max(-block.speed, targetX - block.currentX);
    }

    if (block.currentY < targetY) {
        block.dy = Math.min(block.speed, targetY - block.currentY);
    } else if (block.currentY > targetY) {
        block.dy = Math.max(-block.speed, targetY - block.currentY);
    }

    block.currentX += block.dx;
    block.currentY += block.dy;

    if (block.dx === 0 && block.x1 !== block.x2) {
        block.vx *= -1;
    }
    if (block.dy === 0 && block.y1 !== block.y2) {
        block.vy *= -1;
    }
}


function update() {
    if (gameState === 'MENU') {
        menuScrollY = (menuScrollY + 0.5) % 40; 
        menuWaveOffset = (menuWaveOffset + 0.05); 
        if (shake > 0) shake *= 0.9;
        if (shake < 0.5) shake = 0;
        return;
    }

    pulseTimer = (pulseTimer + 1) % (CONFIG.pulseRate * 2);

    if (shake > 0) shake *= 0.9;
    if (shake < 0.5) shake = 0;

    player.scaleX += (1 - player.scaleX) * 0.1;
    player.scaleY += (1 - player.scaleY) * 0.1;

    if (player.dead) return;

    player.isWalled = 0;
    let platformUnderPlayer = null;
    let jumpedByPad = false; 
    let onGroundThisFrame = false;

    // --- 1. Update Platform Movement ---
    currentMap.blocks.forEach(block => updateMovingPlatforms(block));
    
    // --- 2. Horizontal Movement and Collision (X-axis) ---

    let movingRight = keys['ArrowRight'] || keys['KeyD'];
    let movingLeft = keys['ArrowLeft'] || keys['KeyA'];

    if (movingRight) {
        if (player.vx < CONFIG.speed) player.vx++;
    } 
    else if (movingLeft) {
        if (player.vx > -CONFIG.speed) player.vx--;
    } 
    else {
        player.vx *= CONFIG.friction;
    }

    player.x += player.vx;
    
    // Remove collected blocks outside the loop after checking collisions
    const blocksToRemove = []; 

    for (let i = 0; i < currentMap.blocks.length; i++) {
        let b = currentMap.blocks[i];
        let blockRect = (b.type === 6) ? {x: b.currentX, y: b.currentY, w: b.w, h: b.h} : b;

        if (checkRect(player, blockRect)) {
            if (isBlockHazardous(b)) { die(); return; }
            if (b.type === 3) { advanceLevel(); return; }
            
            // KEY COLLECTION LOGIC (Type 10)
            if (b.type === 10) {
                currentMap.hasKey = true; 
                shake = 5;
                spawnParticles(b.x + b.w/2, b.y + b.h/2, CONFIG.colors.key, 25);
                blocksToRemove.push(i);
                continue; 
            }

            if (isBlockSolid(b)) {
                // Bounce Wall (Type 8) Logic
                if (b.type === 8) {
                    player.vx *= -1.5; 
                    player.vy = -10; 
                    shake = 8;
                    squash(0.5, 1.5);
                    spawnParticles(player.x + player.w/2, player.y + player.h/2, CONFIG.colors.bounce, 15);
                    if (player.x > blockRect.x + blockRect.w/2) {
                        player.x = blockRect.x + blockRect.w; 
                    } else {
                        player.x = blockRect.x - player.w; 
                    }
                    continue; 
                }

                // Normal Solid/Wall Collision
                if (player.vx > 0) {
                    player.x = blockRect.x - player.w;
                    player.isWalled = 1; 
                } else if (player.vx < 0) {
                    player.x = blockRect.x + blockRect.w;
                    player.isWalled = -1; 
                }
                player.vx = 0;
            }
        }
    }
    
    // Apply block removal (in reverse index order)
    for (let i = blocksToRemove.length - 1; i >= 0; i--) {
        currentMap.blocks.splice(blocksToRemove[i], 1);
    }


    // --- 3. Vertical Movement, Gravity, and Collision (Y-axis) ---
    
    // Wall Sliding Logic
    if (player.isWalled !== 0 && !player.canJump && (movingRight || movingLeft)) {
        if (player.vy > 0) {
            player.vy = Math.min(player.vy, CONFIG.wallSlideSpeed);
            player.jumpCount = 0; 
        }
    } else {
        player.vy += CONFIG.gravity;
    }
    
    if (player.canJump) {
        player.coyoteTimer = CONFIG.coyoteTime;
    } else if (player.coyoteTimer > 0) {
        player.coyoteTimer--;
    }

    let tempPlayer = { ...player, y: player.y + 1 }; 

    for (let b of currentMap.blocks) {
        let blockRect = (b.type === 6) ? {x: b.currentX, y: b.currentY, w: b.w, h: b.h} : b;

        if (isBlockSolid(b) && checkRect(tempPlayer, blockRect)) {
            if (player.y + player.h <= blockRect.y) {
                platformUnderPlayer = b;
                break;
            }
        }
    }

    if (platformUnderPlayer && platformUnderPlayer.type === 6) {
        player.x += platformUnderPlayer.dx;
        player.y += platformUnderPlayer.dy;
    }


    player.y += player.vy;
    player.canJump = false; 

    // Y Collisions
    for (let i = 0; i < currentMap.blocks.length; i++) {
        let b = currentMap.blocks[i];
        let blockRect = (b.type === 6) ? {x: b.currentX, y: b.currentY, w: b.w, h: b.h} : b;

        if (checkRect(player, blockRect)) {
            if (isBlockHazardous(b)) { die(); return; }
            if (b.type === 3) { advanceLevel(); return; }

            // KEY COLLECTION LOGIC (Type 10) (Checked again for the off chance vertical movement hits it)
             if (b.type === 10) {
                currentMap.hasKey = true; 
                shake = 5;
                spawnParticles(b.x + b.w/2, b.y + b.h/2, CONFIG.colors.key, 25);
                currentMap.blocks.splice(i, 1); 
                i--; // Adjust index since we removed an element
                continue; 
            }

            if (isBlockSolid(b)) {
                // JUMP PAD LOGIC (Type 7)
                if (b.type === 7 && player.vy > 0) { 
                    player.y = blockRect.y - player.h;
                    player.vy = b.launchY; 
                    player.vx = b.launchX; 
                    player.jumpCount = 0;
                    squash(1.5, 0.5);
                    spawnParticles(player.x + player.w/2, player.y + player.h, CONFIG.colors.jumpPad, 20);
                    jumpedByPad = true;
                    break;
                }
                
                // BOUNCE WALL Y COLLISION (Type 8)
                if (b.type === 8) {
                    if (player.vy > 0) { 
                        player.y = blockRect.y - player.h;
                        player.vy = -18; 
                        squash(1.5, 0.5);
                        spawnParticles(player.x + player.w/2, player.y + player.h, CONFIG.colors.bounce, 15);
                    } else if (player.vy < 0) { 
                        player.y = blockRect.y + blockRect.h;
                        player.vy *= -0.5; 
                        shake = 5;
                    }
                    continue; 
                }

                // Hitting Floor (Normal & Moving Blocks)
                if (player.vy > 0 && !jumpedByPad) {
                    player.y = blockRect.y - player.h;
                    player.vy = 0;
                    player.canJump = true;
                    player.jumpCount = 0;
                    onGroundThisFrame = true;
                    if (player.vy > 10) squash(1.4, 0.6); 
                }
                // Hitting Ceiling
                else if (player.vy < 0) {
                    player.y = blockRect.y + blockRect.h;
                    player.vy = 0;
                }
            }
        }
    }
    
    if (onGroundThisFrame) {
        player.coyoteTimer = CONFIG.coyoteTime;
    }

    if (player.y > 600) die();
}

function advanceLevel() {
    if (gameState !== 'PLAYING') return;
    
    if (currentLevelIndex >= getHighestCompletedLevel() && currentLevelIndex < levels.length - 1) {
        localStorage.setItem('neonPulseHighestLevel', currentLevelIndex + 1);
        CONFIG.highestCompletedLevel = currentLevelIndex + 1;
    }
    
    currentLevelIndex++;
    
    if (currentLevelIndex < levels.length) {
        winGame(false);
    } else {
        winGame(true);
    }
}

function die() {
    if (gameState !== 'PLAYING') return;
    gameState = 'DEAD';
    player.dead = true;
    player.deaths++; 
    player.sessionDeaths = (player.sessionDeaths || 0) + 1; 
    localStorage.setItem('neonPulseDeaths', player.deaths);
    updateHUD();
    shake = 20;
    spawnParticles(player.x, player.y, CONFIG.colors.player, 50);
}

function winGame(finalWin) {
    if (gameState !== 'PLAYING') return;
    gameState = 'WIN';
    player.dead = true; 
    shake = 10;
    spawnParticles(player.x, player.y, CONFIG.colors.goal, 50);
}

// --- RENDER ENGINE ---

function drawText(text, x, y, size, color, align = 'center', glowColor = color, glowBlur = 20) {
    ctx.shadowBlur = glowBlur;
    ctx.shadowColor = glowColor;
    ctx.font = `${size}px "Courier New"`;
    ctx.textAlign = align;
    ctx.fillStyle = color;
    ctx.fillText(text, x, y);
    ctx.shadowBlur = 0;
}

function drawGrid(offsetY = 0, color = 'rgba(100, 100, 100, 0.1)', wave = false) {
    ctx.strokeStyle = color;
    ctx.lineWidth = 1;
    
    // Vertical lines
    for(let i=0; i<800; i+=40) { ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,600); ctx.stroke(); }
    
    // Horizontal lines (with optional wave effect)
    for(let i=-40; i<600; i+=40) { 
        ctx.beginPath(); 
        
        if (wave) {
            ctx.lineWidth = 1.5;
            for(let j=0; j<800; j+=10) {
                const waveY = i + offsetY + Math.sin(j / 50 + menuWaveOffset) * 5;
                if (j === 0) {
                    ctx.moveTo(j, waveY);
                } else {
                    ctx.lineTo(j, waveY);
                }
            }
            ctx.stroke();
        } else {
            ctx.moveTo(0,i + offsetY); 
            ctx.lineTo(800,i + offsetY); 
            ctx.stroke();
        }
    }
    ctx.lineWidth = 1;
}

function drawMainMenu() {
    ctx.fillStyle = CONFIG.colors.bg;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    drawGrid(menuScrollY, 'rgba(0, 255, 255, 0.15)', true);

    updateMainMenuOptions();

    // Title
    drawText("NEON PULSE", canvas.width / 2, canvas.height / 2 - 120, 70, CONFIG.colors.player, 'center', CONFIG.colors.player, 40);
    
    // Menu Options
    const startY = canvas.height / 2;
    CONFIG.mainMenuOptions.forEach((option, index) => {
        const isSelected = index === player.menuSelection;
        let color = isSelected ? CONFIG.colors.goal : 'rgba(255, 255, 255, 0.5)';
        let glowColor = isSelected ? CONFIG.colors.goal : 'rgba(0, 0, 0, 0)';
        let glowBlur = isSelected ? 15 : 0;
        
        // Selection Indicator: Animated Box
        if (isSelected) {
            const time = Date.now() / 150;
            const w = ctx.measureText(option).width + 60;
            const h = 32;
            const x = canvas.width / 2 - w / 2;
            const y = startY + index * 40 - 25;
            
            // Pulsing highlight
            ctx.shadowColor = CONFIG.colors.player;
            ctx.shadowBlur = 20;
            ctx.strokeStyle = CONFIG.colors.player;
            ctx.lineWidth = 2 + 1 * Math.sin(time * 0.5); 
            ctx.strokeRect(x, y, w, h);
            
            // Inner flashing line
            ctx.shadowBlur = 0;
            ctx.strokeStyle = `rgba(255, 255, 255, ${0.4 + 0.3 * Math.sin(time)})`;
            ctx.lineWidth = 1;
            ctx.strokeRect(x + 5, y + 5, w - 10, h - 10);
            
            ctx.shadowBlur = glowBlur;
        }

        drawText(option, canvas.width / 2, startY + index * 40, 28, color, 'center', glowColor, glowBlur);
    });
    
    drawText(`TOTAL GLOBAL DEATHS: ${player.deaths}`, canvas.width / 2, canvas.height / 2 + 180, 18, CONFIG.colors.lava, 'center', CONFIG.colors.lava, 10);
    drawText(`USE ARROWS/WASD TO SELECT | ENTER/SPACE TO CONFIRM`, canvas.width / 2, canvas.height - 50, 14, 'rgba(255, 255, 255, 0.5)', 'center', 'rgba(0, 0, 0, 0)', 0);
}

function drawLevelSelect() {
    ctx.fillStyle = CONFIG.colors.bg;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    drawGrid(menuScrollY, 'rgba(0, 255, 255, 0.1)', true);
    
    drawText("SELECT PROTOCOL LEVEL", canvas.width / 2, 80, 50, CONFIG.colors.player, 'center', CONFIG.colors.player, 30);
    
    const maxLevels = levels.length - 1; 
    const cols = 5;
    const rows = Math.ceil(maxLevels / cols);
    const cellWidth = 120;
    const cellHeight = 70;
    const startX = canvas.width / 2 - (cols * cellWidth) / 2 + cellWidth / 2;
    const startY = 150;
    const highestLevel = getHighestCompletedLevel();

    for (let i = 0; i < maxLevels; i++) {
        const col = i % cols;
        const row = Math.floor(i / cols);
        const x = startX + col * cellWidth;
        const y = startY + row * cellHeight;
        
        const isSelected = i === player.menuSelection;
        const isUnlocked = i <= highestLevel;
        let color = isSelected ? CONFIG.colors.goal : (isUnlocked ? CONFIG.colors.wall : 'rgba(100, 100, 100, 0.3)');
        let glowColor = isSelected ? CONFIG.colors.goal : 'rgba(0, 0, 0, 0)';
        let glowBlur = isSelected ? 15 : 0;
        let text = isUnlocked ? `[${i + 1}]` : `[--]`;

        // Draw selection pulse only if unlocked
        if (isSelected) {
            if (isUnlocked) {
                ctx.shadowColor = CONFIG.colors.player;
                ctx.shadowBlur = 15;
                ctx.strokeStyle = CONFIG.colors.player;
                ctx.lineWidth = 3;
                ctx.strokeRect(x - 30, y - 25, 60, 30);
            } else {
                 ctx.shadowColor = CONFIG.colors.lava;
                 ctx.shadowBlur = 5;
                 ctx.strokeStyle = CONFIG.colors.lava;
                 ctx.lineWidth = 1;
                 ctx.strokeRect(x - 30, y - 25, 60, 30);
            }
        }


        drawText(text, x, y, 24, color, 'center', glowColor, glowBlur);
    }

    drawText(`USE ARROWS/WASD TO SELECT | ENTER/SPACE TO BEGIN`, canvas.width / 2, canvas.height - 50, 14, 'rgba(255, 255, 255, 0.5)', 'center', 'rgba(0, 0, 0, 0)', 0);
    drawText(`(Press ESC/B to return)`, canvas.width / 2, canvas.height - 30, 12, 'rgba(255, 255, 255, 0.3)', 'center', 'rgba(0, 0, 0, 0)', 0);
}

function drawControls() {
    ctx.fillStyle = CONFIG.colors.bg;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    drawGrid(menuScrollY, 'rgba(0, 255, 255, 0.1)', true);
    
    drawText("SYSTEM CONTROLS AND LORE", canvas.width / 2, 80, 50, CONFIG.colors.player, 'center', CONFIG.colors.player, 30);
    
    const rules = [
        ["MOVEMENT", "Arrows / WASD", "Normal navigation."],
        ["JUMP", "Space / Up / W", "Single, Double, or Coyote Jump."],
        ["WALL-JUMP", "Jump against a wall", "Propel yourself away from surfaces."],
        ["R-KEY", "Restart Level", "Quick reset after death or stage clear."],
        ["ESC/B", "Back to Menu", "Only available in sub-menus."],
    ];

    const lore = [
        "LORE: You are an autonomous maintenance drone, PULSE, navigating a corrupted digital environment.",
        "Your mission is to clear corrupted blocks and reach the data core (yellow block).",
        "Avoid high-impact surfaces (red/green) and be wary of unstable platforms (orange pulse).",
        "PHASING BLOCKS (Blue/Magenta) become deadly spikes on a cycle.",
        "NEW OBJECTIVES: Collect KEY BLOCKS (Yellow) to dissolve LOCK BLOCKS (Gray)."
    ];

    let currentY = 150;

    // Controls Table
    drawText(":: CORE MECHANICS ::", canvas.width / 2, currentY, 24, CONFIG.colors.goal, 'center', CONFIG.colors.goal, 10);
    currentY += 40;
    
    rules.forEach(item => {
        drawText(item[0] + ":", canvas.width / 2 - 150, currentY, 18, CONFIG.colors.wall, 'left', CONFIG.colors.wall, 5);
        drawText(item[1], canvas.width / 2 + 50, currentY, 18, CONFIG.colors.player, 'left', CONFIG.colors.player, 5);
        drawText(item[2], canvas.width / 2, currentY + 20, 12, 'rgba(255, 255, 255, 0.5)', 'center', 'rgba(0, 0, 0, 0)', 0);
        currentY += 50;
    });

    // Lore Section
    currentY += 30;
    drawText(":: DATA CORRUPTION LOGS ::", canvas.width / 2, currentY, 24, CONFIG.colors.lava, 'center', CONFIG.colors.lava, 10);
    currentY += 40;

    lore.forEach(line => {
        drawText(line, canvas.width / 2, currentY, 14, 'rgba(255, 255, 255, 0.7)', 'center', 'rgba(0, 0, 0, 0)', 0);
        currentY += 25;
    });

    drawText(`(Press ESC/Enter to return to Main Menu)`, canvas.width / 2, canvas.height - 50, 14, 'rgba(255, 255, 255, 0.5)', 'center', 'rgba(0, 0, 0, 0)', 0);
}


function drawSpike(b, color) {
    ctx.fillStyle = color;
    ctx.shadowColor = color;
    ctx.shadowBlur = 10;
    ctx.beginPath();
    
    let midX = b.x + b.w / 2;
    let topY = b.y;
    let bottomY = b.y + b.h;

    ctx.moveTo(midX, topY); 
    ctx.lineTo(b.x, bottomY); 
    ctx.lineTo(b.x + b.w, bottomY); 
    ctx.closePath();
    ctx.fill();

    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.shadowBlur = 0;
}

function drawJumpPad(b) {
    ctx.fillStyle = CONFIG.colors.jumpPad;
    ctx.shadowColor = CONFIG.colors.jumpPad;
    ctx.shadowBlur = 15;
    
    ctx.fillRect(b.x, b.y, b.w, b.h);

    ctx.shadowBlur = 0;
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 4;
    
    let midX = b.x + b.w / 2;
    let midY = b.y + b.h / 2;
    
    let targetX = midX + b.launchX * 2; 
    let targetY = midY + b.launchY * 2; 

    ctx.beginPath();
    ctx.moveTo(midX, midY);
    ctx.lineTo(targetX, targetY);
    ctx.stroke();

    let angle = Math.atan2(targetY - midY, targetX - midX);
    let arrowSize = 8;
    
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.moveTo(targetX, targetY);
    ctx.lineTo(targetX - arrowSize * Math.cos(angle - Math.PI / 6), targetY - arrowSize * Math.sin(angle - Math.PI / 6));
    ctx.lineTo(targetX - arrowSize * Math.cos(angle + Math.PI / 6), targetY - arrowSize * Math.sin(angle + Math.PI / 6));
    ctx.closePath();
    ctx.fill();

    ctx.shadowBlur = 15;
}

function drawBounceWall(b) {
    ctx.fillStyle = CONFIG.colors.bounce;
    ctx.shadowColor = CONFIG.colors.bounce;
    ctx.shadowBlur = 15;
    ctx.fillRect(b.x, b.y, b.w, b.h);
    
    ctx.shadowBlur = 0;
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    const offset = 1 + 2 * Math.sin(Date.now() / 100);
    
    ctx.beginPath();
    ctx.moveTo(b.x + offset, b.y);
    ctx.lineTo(b.x + b.w - offset, b.y + b.h);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(b.x + b.w, b.y + offset);
    ctx.lineTo(b.x, b.y + b.h - offset);
    ctx.stroke();
}

function drawPhaseBlock(b) {
    const isSolid = pulseTimer < CONFIG.pulseRate;
    
    if (isSolid) {
        ctx.strokeStyle = CONFIG.colors.phaseSolid;
        ctx.shadowColor = CONFIG.colors.phaseSolid;
        ctx.lineWidth = 2;
        ctx.shadowBlur = 15;
        ctx.strokeRect(b.x, b.y, b.w, b.h);
    } else {
        drawSpike(b, CONFIG.colors.phaseSpike);
    }
}

function drawKey(b) {
    const time = Date.now() / 200;
    const pulse = 1 + Math.sin(time) * 0.1;

    ctx.save();
    ctx.translate(b.x + b.w / 2, b.y + b.h / 2);
    ctx.scale(pulse, pulse);
    ctx.translate(-(b.x + b.w / 2), -(b.y + b.h / 2));

    ctx.fillStyle = CONFIG.colors.key;
    ctx.shadowColor = CONFIG.colors.key;
    ctx.shadowBlur = 15;
    
    // Draw Key shape (simplified diamond)
    ctx.beginPath();
    ctx.moveTo(b.x + b.w/2, b.y + 5);
    ctx.lineTo(b.x + b.w - 5, b.y + b.h/2);
    ctx.lineTo(b.x + b.w/2, b.y + b.h - 5);
    ctx.lineTo(b.x + 5, b.y + b.h/2);
    ctx.closePath();
    ctx.fill();

    ctx.restore();
}

function drawLock(b) {
    ctx.fillStyle = CONFIG.colors.lock;
    ctx.shadowColor = CONFIG.colors.lock;
    ctx.shadowBlur = 15;
    ctx.fillRect(b.x, b.y, b.w, b.h);

    // Draw chain/padlock visual
    ctx.shadowBlur = 0;
    ctx.strokeStyle = '#555555';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(b.x + 5, b.y + b.h/2);
    ctx.lineTo(b.x + b.w - 5, b.y + b.h/2);
    ctx.stroke();
}


function drawGame() {
    ctx.save();
    let dx = (Math.random() - 0.5) * shake;
    let dy = (Math.random() - 0.5) * shake;
    ctx.translate(dx, dy);

    ctx.fillStyle = CONFIG.colors.bg;
    ctx.fillRect(-50, -50, canvas.width+100, canvas.height+100);
    drawGrid(0);

    // 2. Map
    currentMap.blocks.forEach(b => {
        let drawRect = (b.type === 6) ? {x: b.currentX, y: b.currentY, w: b.w, h: b.h} : b;
        ctx.shadowBlur = 15;
        
        if (b.type === 1) { // Wall
            ctx.strokeStyle = CONFIG.colors.wall;
            ctx.shadowColor = CONFIG.colors.wall;
            ctx.lineWidth = 2;
            ctx.strokeRect(b.x, b.y, b.w, b.h);
        } else if (b.type === 2) { // Lava
            ctx.fillStyle = CONFIG.colors.lava;
            ctx.shadowColor = CONFIG.colors.lava;
            ctx.fillRect(b.x, b.y + 5, b.w, b.h - 5);
        } else if (b.type === 4) { // Spike
            drawSpike(b, CONFIG.colors.spike);
        } else if (b.type === 3) { // Goal
            ctx.fillStyle = CONFIG.colors.goal;
            ctx.shadowColor = CONFIG.colors.goal;
            ctx.fillRect(b.x, b.y, b.w, b.h);
            ctx.fillStyle = '#fff';
            ctx.fillRect(b.x + 10, b.y + 10, b.w - 20, b.h - 20);
        } else if (b.type === 5) { // Pulsing Block 
            let isHazard = isBlockHazardous(b);
            ctx.shadowColor = isHazard ? CONFIG.colors.pulse : CONFIG.colors.wall;
            
            if (isHazard) {
                ctx.fillStyle = CONFIG.colors.pulse;
                ctx.fillRect(b.x, b.y, b.w, b.h);
                ctx.lineWidth = 2;
                ctx.strokeRect(b.x, b.y, b.w, b.h);
            } else {
                ctx.strokeStyle = CONFIG.colors.wall;
                ctx.lineWidth = 2;
                ctx.strokeRect(b.x, b.y, b.w, b.h);
            }
        } else if (b.type === 6) { // Moving Platform
            ctx.fillStyle = CONFIG.colors.moving;
            ctx.shadowColor = CONFIG.colors.moving;
            ctx.fillRect(drawRect.x, drawRect.y, drawRect.w, drawRect.h);
            ctx.shadowBlur = 0;
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(b.x1 + b.w/2, b.y1 + b.h/2);
            ctx.lineTo(b.x2 + b.w/2, b.y2 + b.h/2);
            ctx.stroke();
            ctx.shadowBlur = 15;
        } else if (b.type === 7) { // Jump Pad
            drawJumpPad(b);
        } else if (b.type === 8) { // Bounce Wall
            drawBounceWall(b);
        } else if (b.type === 9) { // Phase Block
            drawPhaseBlock(b);
        } else if (b.type === 10) { // Key
            drawKey(b);
        } else if (b.type === 11 && !currentMap.hasKey) { // Lock
            drawLock(b);
        }

        ctx.shadowBlur = 0;
    });

    // 3. Particles
    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.03;
        
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, 4, 4);
        ctx.globalAlpha = 1;

        if (p.life <= 0) particles.splice(i, 1);
    }

    // 4. Player
    if (!player.dead) {
        let cx = player.x + player.w/2;
        let cy = player.y + player.h;

        ctx.translate(cx, cy);
        ctx.scale(player.scaleX, player.scaleY);
        ctx.translate(-cx, -cy);

        ctx.shadowBlur = 20;
        ctx.shadowColor = CONFIG.colors.player;
        ctx.fillStyle = CONFIG.colors.player;
        ctx.fillRect(player.x, player.y, player.w, player.h);
        
        ctx.fillStyle = '#fff';
        ctx.fillRect(player.x+6, player.y+6, player.w-12, player.h-12);
        
        ctx.shadowBlur = 0;
        ctx.setTransform(1, 0, 0, 1, 0, 0); 
    }

    // 5. Game Status UI 
    ctx.setTransform(1, 0, 0, 1, dx, dy);
    
    if (gameState === 'PLAYING') {
        drawText(`LEVEL ${currentLevelIndex + 1} / ${levels.length - 1}`, 400, 40, 24, CONFIG.colors.player, 'center', CONFIG.colors.player, 10);
        
        if (currentMap.hasKey) {
             drawText("KEY COLLECTED", 700, 40, 18, CONFIG.colors.key, 'right', CONFIG.colors.key, 10);
        } else if (currentMap.blocks.some(b => b.type === 11)) {
             drawText("KEY REQUIRED", 700, 40, 18, CONFIG.colors.lock, 'right', CONFIG.colors.lock, 10);
        }
        
        drawText("Arrows/WASD to Move | Space/W to Jump | Wall-Jump Enabled", 400, 580, 12, 'rgba(255, 255, 255, 0.3)', 'center', 'rgba(0, 0, 0, 0)', 0);
    } else if (gameState === 'DEAD') {
        drawText("FATAL ERROR. PRESS R TO RESTART.", 400, 300, 40, CONFIG.colors.lava, 'center', CONFIG.colors.lava, 30);
        drawText(`Total Deaths: ${player.deaths}`, 400, 360, 20, CONFIG.colors.lava, 'center', CONFIG.colors.lava, 10);
    } else if (gameState === 'WIN') {
        const finalLevelIndex = levels.length - 1;
        let primaryText = currentLevelIndex >= finalLevelIndex ? "PROTOCOL COMPLETE. PRESS R TO REBOOT." : `LEVEL ${currentLevelIndex} CLEARED. PRESS R FOR LEVEL ${currentLevelIndex + 1}`;
        let subText = currentLevelIndex >= finalLevelIndex ? `Session Deaths: ${player.sessionDeaths}. Total Deaths: ${player.deaths}. Press R to Return to Menu` : "Press R to Continue";
        
        drawText(primaryText, 400, 300, 30, CONFIG.colors.goal, 'center', CONFIG.colors.goal, 30);
        drawText(subText, 400, 360, 18, CONFIG.colors.goal, 'center', CONFIG.colors.goal, 10);
    }
    
    ctx.restore();

    // 6. Scanline/CRT Effect 
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.fillStyle = "rgba(0, 0, 0, 0.25)"; 
    for (let i = 0; i < canvas.height; i += 3) { 
        ctx.fillRect(0, i, canvas.width, 1.5);
    }
}

function draw() {
    if (gameState === 'MENU') {
        if (player.menuState === 'MAIN') {
            drawMainMenu();
        } else if (player.menuState === 'LEVEL_SELECT') {
            drawLevelSelect();
        } else if (player.menuState === 'CONTROLS') {
            drawControls();
        }
    } else {
        drawGame();
    }
}

// --- INITIALIZATION ---
function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}

// Initial setup to read persistence and update the menu
updateMainMenuOptions();
document.getElementById('death-counter').innerText = `TOTAL DEATHS: ${player.deaths}`; 

loop();
</script>
</body>
</html>
